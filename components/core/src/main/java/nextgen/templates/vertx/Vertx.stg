delimiters "~","~"

DomainVerticle(packageName,name,actions,domainFactory,address) ::= <<package ~packageName~;

import ~packageName~.messages.*;
import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.core.eventbus.Message;
import io.vertx.core.json.JsonObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class ~name;format="capitalize"~ extends AbstractVerticle {

	private static final Logger log = LoggerFactory.getLogger(~name;format="capitalize"~.class);

	public enum Action {
		~actions:{it|~it.name~};separator=",\n"~
	}

	public enum ErrorCodes {
		NO_ACTION_HEADER,
		UNKNOWN_ACTION,
		DB_ERROR
	}

	private ~domainFactory~ db;

	@Override
	public void start(Promise<Void> promise) throws Exception {
		db = new ~domainFactory~(config().getString("path"));
		vertx.eventBus().consumer(config().getString("~address~", "~address~"), this::onMessage);
	}

	public void onMessage(Message<JsonObject> message) {

		if (!message.headers().contains("action")) {
			log.error("No action header specified for message with headers {} and body {}", message.headers(), message.body().encodePrettily());
			message.fail(ErrorCodes.NO_ACTION_HEADER.ordinal(), "No action header specified");
			return;
		}

		final Action action = getAction(message);
		
		if (action == null) {
			message.fail(ErrorCodes.UNKNOWN_ACTION.ordinal(), "Unknown action");
			return;
		}

		switch (action) {
~actions:{it|
			case ~it.name~: {
				~it.name~(message);
				break;
			\}};separator="\n"~
		}
	}

	~actions:{it|~it.declaration~};separator="\n\n"~

	private Action getAction(Message<JsonObject> message) {
		final String action = message.headers().get("action");
		try {
			return Action.valueOf(action);
		} catch (Throwable e) {
			log.error("Unknown action " + action);
			return null;
		}
	}
}  >>

DomainAction(name,params,statements) ::= <<private void ~name~(Message<JsonObject> message) {
~if(params)~
	final JsonObject body = message.body();
	~params:{it|final ~it.type~ ~it.name~ = body.get~it.type~("~it.name~");};separator="\n"~
~endif~
	
	db.doInTransaction(transaction -> {
		~statements:{it|~it~};separator="\n"~
	}, throwable -> {
		message.fail(ErrorCodes.DB_ERROR.ordinal(), throwable.getMessage());
	});
}  >>

Entities() ::= << >>

JsonWrapper(package,name,externalFields,accessors,neoNodeMapper,lexical) ::= <<package ~package~;

public class ~name;format="capitalize"~ {

	private final io.vertx.core.json.JsonObject jsonObject;
	~externalFields:{it|private ~it.type~ _~it.name~~if(it.initializer)~ = ~it.initializer~~endif~;};separator="\n"~

	public ~name;format="capitalize"~() { 
		this.jsonObject = new io.vertx.core.json.JsonObject();
		jsonObject.put("uuid", java.util.UUID.randomUUID().toString());
	}

	public ~name;format="capitalize"~(io.vertx.core.json.JsonObject jsonObject) { 
		this.jsonObject = jsonObject;
		java.lang.String uuidString = jsonObject.getString("uuid");
		if (uuidString == null) jsonObject.put("uuid", java.util.UUID.randomUUID().toString());
	}

	public io.vertx.core.json.JsonObject getJsonObject() { 
		return this.jsonObject;
	}

	@Deprecated
	public String uuid() {
		return this.jsonObject.getString("uuid");
	}

	public String getUuid() {
		return this.jsonObject.getString("uuid");
	}
	
	public ~name;format="capitalize"~ removeUuid() {
		this.jsonObject.remove("uuid");
		return this;
	}

	@Override
	public boolean equals(java.lang.Object o) { 
		if (this == o) return true;
		if (o == null || getClass() != o.getClass()) return false;
		final ~name;format="capitalize"~ other = (~name;format="capitalize"~) o;
		return jsonObject.getString("uuid").equals(other.getJsonObject().getString("uuid"));
	}

	@Override
	public int hashCode() { 
		return java.util.Objects.hash(jsonObject.getString("uuid"));
	}

	~accessors:{it|~it~};separator="\n\n"~

	~neoNodeMapper~

	@Override
	public java.lang.String toString() { 
		return ~if(lexical)~jsonObject.getString("~lexical~")~else~jsonObject.encode()~endif~;
	}
}  >>

primitiveAccessors(className,name,type) ::= <<public ~className;format="capitalize"~ set~name;format="dotToCap"~(~type~ value) { 
	jsonObject.put("~name~", value);
	return this;
}

public ~type~ get~name;format="dotToCap"~() { 
	return jsonObject.get~type;format="capitalize"~("~name~");
}

public ~type~ get~name;format="dotToCap"~(~type~ defaultValue) { 
	return jsonObject.get~type;format="capitalize"~("~name~", defaultValue);
} >>

listReferenceAccessors(className,name,type) ::= <<public ~className;format="capitalize"~ add~name;format="capitalize"~(~type~ value) { 
	io.vertx.core.json.JsonArray jsonArray = jsonObject.getJsonArray("~name~");
	if (jsonArray == null) jsonObject.put("~name~", jsonArray = new io.vertx.core.json.JsonArray());
	jsonArray.add(value.getJsonObject());
	return this;
}

public java.util.stream.Stream<~type~> get~name;format="capitalize"~() { 
	return jsonObject.getJsonArray("~name~", new io.vertx.core.json.JsonArray()).stream().map((o) -> new ~type~((io.vertx.core.json.JsonObject) o));
}

public ~className;format="capitalize"~ remove~name;format="capitalize"~(~type~ value) { 
	final io.vertx.core.json.JsonArray jsonArray = jsonObject.getJsonArray("~name~", new io.vertx.core.json.JsonArray());
	for (int i = 0; i < jsonArray.size(); i++)  { 
		final io.vertx.core.json.JsonObject o = jsonArray.getJsonObject(i);
		if (value.getJsonObject().getString("uuid").equals(o.getString("uuid")))  { 
			jsonArray.remove(i);
			return this;
		}
	}
	return this;
}

public ~className;format="capitalize"~ clear~name;format="capitalize"~() { 
	jsonObject.put("~name~", new io.vertx.core.json.JsonArray());
	return this;
} >>

referenceAccessors(className,name,type) ::= <<public ~className;format="capitalize"~ set~name;format="capitalize"~(~type~ value) { 
	jsonObject.put("~name~", value.getJsonObject());
	return this;
}

public ~type~ get~name;format="capitalize"~() { 
	return jsonObject.getJsonObject("~name~") == null ? null : new ~type~(jsonObject.getJsonObject("~name~"));
} >>

listPrimitiveAccessors(className,name,type) ::= <<public ~className;format="capitalize"~ add~name;format="capitalize"~(~type~ value) { 
	io.vertx.core.json.JsonArray jsonArray = jsonObject.getJsonArray("~name~");
	if (jsonArray == null) jsonObject.put("~name~", jsonArray = new io.vertx.core.json.JsonArray());
	jsonArray.add(value);
	return this;
}

public java.util.stream.Stream<~type~> get~name;format="capitalize"~() { 
	return jsonObject.getJsonArray("~name~", new io.vertx.core.json.JsonArray()).stream().map((o) -> (~type~)o);
}

public ~className;format="capitalize"~ remove~name;format="capitalize"~(~type~ value) { 
	final io.vertx.core.json.JsonArray jsonArray = jsonObject.getJsonArray("~name~", new io.vertx.core.json.JsonArray());
	for (int i = 0; i < jsonArray.size(); i++)  { 
		final ~type~ o = jsonArray.get~type~(i);
		if (value.equals(o))  { 
			jsonArray.remove(i);
			return this;
		}
	}
	return this;
}

public ~className;format="capitalize"~ clear~name;format="capitalize"~() { 
	jsonObject.put("~name~", new io.vertx.core.json.JsonArray());
	return this;
}  >>

externalAccessors(className,name,type) ::= <<public ~className;format="capitalize"~ set~name;format="capitalize"~(~type~ value) { 
	this._~name~ = value;
	return this;
}

public ~type~ get~name;format="capitalize"~() { 
	return this._~name~;
}

public ~type~ get~name;format="capitalize"~(~type~ defaultValue) { 
	return this._~name~ == null ? defaultValue : this._~name~;
} >>

enumAccessors(className,name,type) ::= <<public ~className;format="capitalize"~ set~name;format="capitalize"~(~type~ value) { 
	if (value == null) return this;
	jsonObject.put("~name~", value.name());
	return this;
}

public ~type~ get~name;format="capitalize"~() { 
	return get~name;format="capitalize"~(null);
}

public ~type~ get~name;format="capitalize"~(~type~ defaultValue) { 
	return jsonObject.getString("~name~") == null ? defaultValue : ~type~.valueOf(jsonObject.getString("~name~"));
} >>

listEnumAccessors(className,name,type) ::= <<public ~className;format="capitalize"~ add~name;format="capitalize"~(~type~ value) { 
	io.vertx.core.json.JsonArray jsonArray = jsonObject.getJsonArray("~name~");
	if (jsonArray == null) jsonObject.put("~name~", jsonArray = new io.vertx.core.json.JsonArray());
	jsonArray.add(value.name());
	return this;
}

public java.util.stream.Stream<~type~> get~name;format="capitalize"~() { 
	return jsonObject.getJsonArray("~name~", new io.vertx.core.json.JsonArray()).stream().map((o) -> ~type~.valueOf(o.toString()));
}

public ~className;format="capitalize"~ remove~name;format="capitalize"~(~type~ value) { 
	final io.vertx.core.json.JsonArray jsonArray = jsonObject.getJsonArray("~name~", new io.vertx.core.json.JsonArray());
	jsonArray.remove(value.name());
	return this;
}

public ~className;format="capitalize"~ clear~name;format="capitalize"~() { 
	jsonObject.put("~name~", new io.vertx.core.json.JsonArray());
	return this;
}  >>

JsonFactory(package,name,entities) ::= <<package ~package~;

public class ~name;format="capitalize"~ {

	public static io.vertx.core.json.JsonObject load(java.io.File file) throws java.io.IOException {
		if (!file.exists() || !file.isFile()) throw new IllegalArgumentException("could not read " + file.getAbsolutePath());
		return new io.vertx.core.json.JsonObject(io.vertx.core.buffer.Buffer.buffer(java.nio.file.Files.readAllBytes(file.toPath())));
	}
	
	public static void save(io.vertx.core.json.JsonObject jsonObject, java.io.File file) throws java.io.IOException {

		if (!file.getParentFile().exists() && !file.getParentFile().mkdirs())
			throw new IllegalStateException("could not create " + file.getParentFile().getAbsolutePath());

		if (!file.exists() && !file.createNewFile())
			throw new IllegalStateException("could not create " + file.getAbsolutePath());

		java.nio.file.Files.write(file.toPath(), jsonObject.toBuffer().getBytes());
	}
	
~entities:{it|
	public static ~it~ new~it~() { 
		return new ~it~();
	\}
	
	public static ~it~ new~it~NoUuid() { 
		return new ~it~().removeUuid();
	\}
	
	public static ~it~ new~it~(io.vertx.core.json.JsonObject jsonObject) { 
		return new ~it~(jsonObject);
	\}

	public static ~it~ new~it~(java.io.File file) throws java.io.IOException { 
		return new ~it~(load(file));
	\}

	public static ~it~ merge(~it~ lhs, ~it~ rhs) {
		return new~it~(lhs.getJsonObject().mergeIn(rhs.getJsonObject()));
	\}
};separator="\n"~
}  >>

WebVerticle(packageName,name,routes,rawRoutes) ::= <<package ~packageName~;

import com.securityx.web.api.LoginRequest;
import com.securityx.web.domain.*;
import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Vertx;
import io.vertx.core.eventbus.DeliveryOptions;
import io.vertx.core.http.HttpServerOptions;
import io.vertx.core.json.JsonObject;
import io.vertx.core.net.PemKeyCertOptions;
import io.vertx.ext.auth.KeyStoreOptions;
import io.vertx.ext.auth.jwt.JWTAuth;
import io.vertx.ext.auth.jwt.JWTAuthOptions;
import io.vertx.ext.jwt.JWTOptions;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.RoutingContext;
import io.vertx.ext.web.handler.BodyHandler;
import io.vertx.ext.web.handler.JWTAuthHandler;
import io.vertx.ext.web.handler.SessionHandler;
import io.vertx.ext.web.handler.StaticHandler;
import io.vertx.ext.web.sstore.LocalSessionStore;

import java.util.Optional;
import java.util.concurrent.atomic.AtomicInteger;

import static com.securityx.web.PasswordUtils.verifyUserPassword;
import static com.securityx.web.WebUtils.sendErrors;
import static com.securityx.web.WebUtils.sendResponse;
import static com.securityx.web.api.WebApiJsonFactory.newJWTPayload;
import static com.securityx.web.api.WebApiJsonFactory.newLoginRequest;
import static com.securityx.web.domain.ServerJsonFactory.newUserMenu;
import static com.securityx.web.domain.ServerJsonFactory.newUserSession;
import static io.netty.handler.codec.http.HttpResponseStatus.*;

public class ~name;format="capitalize"~ extends AbstractVerticle {

	protected final static org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(~name;format="capitalize"~.class);

	@Override
	public void start(Future<Void> startFuture) throws Exception {
		log.info("starting");

		final ~name;format="capitalize"~Config config = new ~name;format="capitalize"~Config(config());

		final KeyStoreOptions keyStoreOptions = new KeyStoreOptions().
					setPath(config.getJwt().getPath()).
					setPassword(config.getJwt().getPassword()).
					setType(config.getJwt().getType());

		final JWTAuthOptions jwtAuthOptions = new JWTAuthOptions().setKeyStore(keyStoreOptions);
		final JWTAuth auth = JWTAuth.create(vertx, jwtAuthOptions);

		final Router router = Router.router(vertx);
		router.route().handler(BodyHandler.create());
		router.route().handler(SessionHandler.create(LocalSessionStore.create(vertx)));
		router.post("/login").handler(routingContext -> login(routingContext, auth, config));
		router.route("/api/*").handler(JWTAuthHandler.create(auth, "/login"));
		router.get("/user").handler(routingContext -> getUser(routingContext, config));
		~routes:{it|router.~it.action~("/api/~it.url~").handler(this::~it.methodName~);};separator="\n"~
		~rawRoutes:{it|router.~it.action~("~it.url~").handler(this::~it.methodName~);};separator="\n"~
		
		final HttpServerOptions serverOptions = new HttpServerOptions();
		final Optional<SSLConfig> ssl = Optional.ofNullable(config.getSsl());

		ssl.ifPresent(sslConfig ->
				serverOptions
						.setSsl(true)
						.setPemKeyCertOptions(
								new PemKeyCertOptions().
											setKeyPath(sslConfig.getKey()).
											setCertPath(sslConfig.getCert())));

		final StaticHandler staticHandler = StaticHandler.create();
		staticHandler.setWebRoot(config.getWebRoot());
		staticHandler.setCachingEnabled(false);
		staticHandler.setIndexPage("index.html");
		router.route("/*").handler(staticHandler);

		vertx.createHttpServer(serverOptions).requestHandler(router::accept).listen(config.getPort());

		log.info("server running on " + (ssl.isPresent() ? "https" : "http") + "://" + config.getTcpHost() + ":" + config.getPort());
		log.info("server running on " + (ssl.isPresent() ? "https" : "http") + "://" + config.getTcpName("securityxresidential.info") + ":" + config.getPort());

		startFuture.succeeded();
	}

	private void login(RoutingContext routingContext, JWTAuth auth, ~name;format="capitalize"~Config deploymentOptions) {
		WebUtils.debug("login", routingContext);

		final LoginRequest loginRequest = newLoginRequest(routingContext.getBodyAsJson());

		final Optional<UserConfig> foundUserConfig = deploymentOptions.getJwt().getUsers()
				.filter(userConfig -> userConfig.getUsername() != null && userConfig.getPassword() != null)
				.filter(userConfig -> userConfig.getUsername().equals(loginRequest.getUsername()))
				.findFirst();

		if (!foundUserConfig.isPresent()) {
			sendErrors(routingContext, UNAUTHORIZED, "User credentials not found");
			return;
		}

		final boolean passwordMatch = verifyUserPassword(loginRequest.getPassword(), foundUserConfig.get().getPassword(), foundUserConfig.get().getSalt());

		if (!passwordMatch) {
			sendErrors(routingContext, UNAUTHORIZED, "User credentials not found");
			return;
		}

		final UserSession userSession = newUserSession()
			.setToken(auth.generateToken(
					newJWTPayload()
							.setSub(foundUserConfig.get().getUsername())
							.getJsonObject(),
					new JWTOptions()
							.setExpiresInMinutes(deploymentOptions.getJwt().getExpiresInMinutes())
							.setSubject(foundUserConfig.get().getUsername())))
			.setUsername(foundUserConfig.get().getUsername());

		final AtomicInteger id = new AtomicInteger(0);
		foundUserConfig.get().getAccess()
			.forEach(webPageAccessSettings -> userSession.addMenus(newUserMenu()
						.setKey(id.incrementAndGet())
						.setLabel(webPageAccessSettings.getLabel())
						.setUrl(webPageAccessSettings.getUrl())));

		foundUserConfig.get().setSession(userSession);

		sendResponse(routingContext, OK, new JsonObject().put("user", userSession.getJsonObject()));
	}

	private void getUser(RoutingContext routingContext, ~name;format="capitalize"~Config deploymentOptions) {
		WebUtils.debug("getUser", routingContext);

		final String authorization = routingContext.request().getHeader("Authorization");
		final String token = authorization == null ? null : authorization.substring(7).trim();

		final Optional<UserSession> userSession = deploymentOptions.getJwt().getUsers()
				.filter(userConfig -> userConfig.getSession() != null)
				.map(UserConfig::getSession)
				.filter(session -> session.getToken().equals(token))
				.findFirst();

		if (!userSession.isPresent())
			sendErrors(routingContext, UNAUTHORIZED,	"User session not found");
		else
			sendResponse(routingContext, OK, new JsonObject().put("user", userSession.get().getJsonObject()));
	}

	~routes:{it|~it.declaration~};separator="\n\n"~
	~rawRoutes:{it|~it.declaration~};separator="\n\n"~

	private static void getFromDomainDB(Vertx vertx, RoutingContext routingContext, String action, JsonObject params) {
		vertx.eventBus().request("domain.db", params, new DeliveryOptions().addHeader("action", action), reply -> {
			if (reply.succeeded()) {
				sendResponse(routingContext, OK, (JsonObject) reply.result().body());
			} else {
				sendErrors(routingContext, INTERNAL_SERVER_ERROR,	"Server Error");
			}
		});
	}
}  >>

SendEventBusAction(actionName,params) ::= <<getFromDomainDB(vertx, routingContext, "~actionName~", new JsonObject()~if(params)~.~params:{it|put("~it.name~", routingContext.request().getParam("~it.name~"))}~~endif~);  >>

RouteHandler(name,statements) ::= <<private void ~name~(RoutingContext routingContext) {
	WebUtils.debug("~name~", routingContext);
	~statements:{it|~it~};separator="\n"~
}  >>

eom() ::= "}"

gt() ::= ">"
