delimiters "~","~"

Entities() ::= << >>

Pojo(package,name,fields,accessors,lexical) ::= <<package ~package~;

public class ~name~ {

	private final java.util.UUID uuid;
	~fields:{it|private ~it.type~ _~it.name~~if(it.initializer)~ = ~it.initializer~~endif~;};separator="\n"~
	
	public ~name~() {
		this.uuid = java.util.UUID.randomUUID();
	}

	public ~name~(java.util.UUID uuid) {
		this.uuid = uuid;
	}

	public java.util.UUID getUuid() {
		return this.uuid;
	}	
	
	~accessors:{it|~it~};separator="\n\n"~
~if(lexical)~

	@Override
	public String toString() {
		return ~lexical:{it|_~it~};separator=" + \" \" + "~;
	}
~endif~

	@Override
	public boolean equals(Object o) {
		if (this == o) return true;
		if (o == null || getClass() != o.getClass()) return false;
		~name~ that = (~name~) o;
		return uuid.equals(that.uuid);
	}

	@Override
	public int hashCode() {
		return java.util.Objects.hash(uuid);
	}
}  >>

primitiveAccessors(type,name,className) ::= <<public ~type~ get~name;format="capitalize"~() {
	return this._~name~;
}

public ~className;format="capitalize"~ set~name;format="capitalize"~(~type~ value) {
	this._~name~ = value;
	return this;
} >>

referenceAccessors(type,name,className) ::= <<public ~type~ get~name;format="capitalize"~() {
	return this._~name~;
}

public ~className;format="capitalize"~ set~name;format="capitalize"~(~type~ value) {
	this._~name~ = value;
	return this;
}

public ~className;format="capitalize"~ remove~name;format="capitalize"~() {
	this._~name~ = null;
	return this;
} >>

listAccessors(type,name,className) ::= <<public java.util.List<~type~> get~name;format="capitalize"~() {
	return this._~name~;
}

public ~className~ add~name;format="capitalize"~(~type~ value) {
	this._~name~.add(value);
	return this;
} >>

PojoFactory(package,name,entities) ::= <<package ~package~;

public class ~name;format="capitalize"~ {

~entities:{it|
	public static ~it~ new~it~() { 
		return new ~it~();
	~eom()~
};separator="\n"~
} >>

Enum(package,name,enumValues) ::= <<package ~package~;

public enum ~name~ {

	~enumValues:{it|~it~};separator=",\n"~
} >>

EnumValue(name,lexical) ::= <<~name~~if(lexical)~() {
	@Override
	public String toString() { return "~lexical~"; }
}~endif~ >>

Grammar() ::= << >>

CompilationUnit(packageDeclaration,types,importDeclaration) ::= <<~packageDeclaration~

~importDeclaration:{it|~it~};separator="\n"~

~types:{it|~it~};separator="\n\n"~ >>

ClassOrInterfaceDeclaration(comments,annotations,modifiers,isInterface,name,typeParameters,extend,implementedTypes,fields,members) ::= <<~comments:{it|~it~};separator="\n"~~if(comments)~
~endif~~annotations:{it|~it~};separator="\n"~~if(annotations)~
~endif~~modifiers:{it|~it~};separator=" "~~if(modifiers)~ ~endif~~if(isInterface)~interface ~else~class ~endif~~name~~if(typeParameters)~<~typeParameters:{it|~it~};separator=", "~>~endif~~if(extend)~ extends ~extend:{it|~it~};separator=", "~~endif~~if(implementedTypes)~ implements ~implementedTypes:{it|~it~};separator=", "~~endif~ {
	
	~fields:{it|~it~};separator="\n"~
	~if(fields)~
	
	~endif~
	~members:{it|~it~};separator="\n\n"~
} >>

FieldDeclaration(variables,annotations,modifiers) ::= <<~annotations:{it|~it~};separator="\n"~~if(annotations)~
~endif~~modifiers:{it|~it~};separator=" "~~if(modifiers)~ ~endif~~variables:{it|~it~};separator=", "~; >>

ConstructorDeclaration(name,blockStmt,modifiers,annotations,thrownExceptions,typeParameters,parameters) ::= <<~annotations:{it|~it~};separator="\n"~~if(annotations)~
~endif~~modifiers:{it|~it~};separator=" "~~if(modifiers)~ ~endif~~if(typeParameters)~~typeParameters:{it|<~it~>};separator=" "~ ~endif~~name~(~parameters:{it|~it~};separator=", "~)~if(thrownExceptions)~ throws ~thrownExceptions:{it|~it~};separator=", "~ ~endif~~if(blockStmt)~~blockStmt~~else~ { }~endif~ >>

EnumDeclaration(name,members,annotations,implementedTypes,entries,extend,modifiers) ::= <<~annotations:{it|~it~};separator="\n"~~if(annotations)~
~endif~~modifiers:{it|~it~};separator=" "~~if(modifiers)~ ~endif~enum ~name~~if(extend)~ extends ~extend:{it|~it~};separator=", "~~endif~~if(implementedTypes)~ implements ~implementedTypes:{it|~it~};separator=","~~endif~ {

	~entries:{it|~it~};separator=",\n"~~if(members)~;~endif~

	~members:{it|~it~};separator="\n\n"~
} >>

EnumConstant(methods,arguments,name,annotations) ::= <<~annotations:{it|~it~};separator="\n"~~if(annotations)~
~endif~~name~~if(arguments)~(~arguments:{it|~it~};separator=","~)~endif~~if(methods)~ {
	~methods:{it|~it~};separator="\n"~
}~endif~ >>

ImportDeclaration(isStatic,name,isAsterisk) ::= <<import ~if(isStatic)~static ~endif~~name~~if(isAsterisk)~.*~endif~; >>

Declarations() ::= << >>

AnnotationDeclaration(members,name,modifiers,annotations) ::= <<~annotations:{it|~it~};separator="\n"~~if(annotations)~
~endif~~modifiers:{it|~it~};separator=" "~~if(modifiers)~ ~endif~@interface ~name~ {
	~members:{it|~it~};separator="\n"~
} >>

AnnotationMemberDeclaration(name,type,defaultValue) ::= <<~type~ ~name~()~if(defaultValue)~ default ~defaultValue~~endif~; >>

FinalFieldDeclaration(initializer,name,type) ::= <<final ~VariableDeclaration(initializer,name,type)~; >>

MethodDeclaration(annotations,modifiers,type,typeParameters,name,parameters,thrownExceptions,isInterfaceDeclaration,blockStmt) ::= <<~annotations:{it|~it~};separator="\n"~~if(annotations)~
~endif~~modifiers:{it|~it~};separator=" "~~if(modifiers)~ ~endif~~if(type)~~if(typeParameters)~<~typeParameters:{it|~it~};separator=", "~> ~endif~~type~ ~else~void ~endif~~name~(~parameters:{it|~it~};separator=", "~)~if(thrownExceptions)~ throws ~thrownExceptions:{it|~it~};separator=", "~~endif~~if(isInterfaceDeclaration)~;~else~~if(blockStmt)~~blockStmt~~else~ { }~endif~~endif~ >>

Parameter(annotations,modifiers,type,isVarargs,name) ::= <<~annotations:{it|~it~};separator=" "~~if(annotations)~ ~endif~~modifiers:{it|~it~};separator=" "~~if(modifiers)~ ~endif~~if(type)~~type~ ~endif~~if(isVarargs)~... ~endif~~name~ >>

ModuleDeclaration(providesDirective,usesDirective,name,requiresDirective,exportsDirective,opens) ::= <<module ~name~ {
    ~requiresDirective:{it|requires ~it~};separator="\n"~
    ~exportsDirective:{it|exports ~it~};separator="\n"~
    ~providesDirective:{it|provides ~it~};separator="\n"~
    ~usesDirective:{it|uses ~it~};separator="\n"~
    ~opens:{it|opens ~it~};separator="\n"~
} >>

PackageDeclaration(name) ::= <<package ~name~; >>

PrivateFieldDeclaration(initializer,name,type) ::= <<private ~VariableDeclaration(initializer,name,type)~; >>

PrivateFinalFieldDeclaration(initializer,name,type) ::= <<private final ~VariableDeclaration(initializer,name,type)~; >>

PublicFinalFieldDeclaration(initializer,name,type) ::= <<public final ~VariableDeclaration(initializer,name,type)~; >>

StaticFinalFieldDeclaration(initializer,name,type) ::= <<static final ~VariableDeclaration(initializer,name,type)~; >>

StaticPrivateFinalFieldDeclaration(initializer,name,type) ::= <<static final ~VariableDeclaration(initializer,name,type)~; >>

staticPublicFinalFieldDeclaration(initializer,name,type) ::= <<static public final ~VariableDeclaration(initializer,name,type)~; >>

VariableDeclaration(name,initializer,type) ::= <<~if(type)~~type~ ~endif~~name~~if(initializer)~ = ~initializer~~endif~ >>

Expressions() ::= << >>

ArrayAccessExpression(index,name) ::= <<~name~[~index~] >>

ArrayCreationExpression(initializer,type,levels) ::= <<new ~type~~levels:{it|~it~}~~if(initializer)~ ~initializer~~endif~ >>

ArrayInitializerExpression(values) ::= <<{
	~values:{it|~it~};separator=",\n"~
} >>

AssignExpression(value,target,operator) ::= <<~target~ ~operator~ ~value~ >>

AssignThisVariableExpression(value) ::= <<~ThisVariableExpression(value)~ = ~value~ >>

UnaryExpression(isPrefix,operator,expression,isPostfix) ::= <<~if(isPrefix)~~operator~~endif~~expression~~if(isPostfix)~~operator~~endif~ >>

ThisVariableExpression(value) ::= <<this.~value~ >>

SuperExpression(typeName) ::= <<super~if(typeName)~.~endif~~typeName~ >>

StringLiteralExpression(value) ::= <<"~value~" >>

ObjectCreationExpression(scope,type,typeArguments,arguments,anonymousClassBodies,emptyClassBody) ::= <<new ~if(scope)~~scope~.~endif~~type~~if(typeArguments)~<~typeArguments:{it|~it~};separator=", "~>~endif~(~arguments:{it|~it~};separator=", "~)~if(anonymousClassBodies)~ {

	~anonymousClassBodies:{it|~it~};separator="\n"~

}~elseif(emptyClassBody)~ {
}~endif~ >>

NormalAnnotationExpression(name,memberValues) ::= <<@~name~~if(memberValues)~(~memberValues:{it|~it~};separator=", "~)~endif~ >>

NullLiteralExpression(value) ::= <<~value~ >>

VariableDeclarationExpression(variables,modifiers) ::= <<~modifiers:{it|~it~};separator=" "~~if(modifiers)~ ~endif~~variables:{it|~it~};separator=", "~ >>

SingleMemberAnnotationExpression(members,name) ::= <<@~name~~if(members)~(~members:{it|~it~};separator=", "~)~endif~ >>

MethodReferenceExpression(identifier,scope) ::= <<~scope~::~identifier~ >>

MethodCallExpression(scope,arguments,typeArguments,name) ::= <<~if(scope)~~scope~.~endif~~if(typeArguments)~<~typeArguments:{it|~it~};separator=","~>~endif~~name~(~arguments:{it|~it~};separator=", "~) >>

MarkerAnnotationExpression(name) ::= <<@~name~ >>

LambdaExpression(body,parameters) ::= <<(~parameters:{it|~it~};separator=", "~) -> ~body~ >>

IntegerLiteralExpression(value) ::= <<~value~ >>

InstanceOfExpression(type,expression) ::= <<~expression~ instanceof ~type~ >>

FieldAccessExpression(scope,name) ::= <<~if(scope)~~scope~.~endif~~name~ >>

EnclosedExpression(expression) ::= <<(~expression~) >>

DoubleLiteralExpression(value) ::= <<~value~ >>

ConditionalExpression(thenExpression,elseExpression,condition) ::= <<~condition~ ? ~thenExpression~ : ~elseExpression~ >>

CharLiteralExpression(value) ::= <<~value~ >>

CastExpression(expression,type) ::= <<(~type~) ~expression~ >>

BooleanLiteralExpression(value) ::= <<~value~ >>

BinaryExpression(left,operator,right) ::= <<~left~ ~operator~ ~right~ >>

LongExpression(value) ::= <<~value~ >>

NameExpression(value) ::= <<~value~ >>

ThisExpression(typeName) ::= <<this~if(typeName)~.~endif~~typeName~ >>

ClassExpression(type) ::= <<~type~.class >>

Statements() ::= << >>

ExpressionStmt(comment,expression) ::= <<~if(comment)~~comment~
~endif~~expression~; >>

ContinueStmt(label) ::= <<continue~if(label)~ ~label~~endif~; >>

SwitchEntryStmt(labels,statements) ::= <<~if(labels)~~labels:{it|case ~it~ :};separator="\n"~~else~default :~endif~
	~statements:{it|~it~};separator="\n"~ >>

SwitchStmt(selector,entries) ::= <<switch(~selector~) {
	~entries:{it|~it~};separator="\n"~
} >>

SynchronizedStmt(expression,body) ::= <<synchronized ( ~expression~ ) ~body~ >>

WhileStmt(condition,body) ::= <<while (~condition~) ~body~ >>

LabeledStmt(statement,label) ::= <<~label~ : 
	~statement~ >>

ForEachStmt(body,variable,iterable) ::= <<for (~variable~ : ~iterable~) ~body~ >>

AssertStmt(message,expression) ::= <<assert ~expression~~if(message)~ : ~message~~endif~; >>

BlockStmt(isStatic,statements) ::= <<~if(isStatic)~ static~endif~ { ~if(statements)~
	~statements:{it|~it~};separator="\n"~
~endif~
} >>

BreakStmt(label) ::= <<break~if(label)~ ~label~~endif~; >>

EmptyStmt() ::= <<; >>

ThrowStmt(expression) ::= <<throw ~expression~; >>

ReturnStmt(expression) ::= <<return~if(expression)~ ~expression~~endif~; >>

IfStmt(condition,then,elseStmt) ::= <<if (~condition~) ~then~~if(elseStmt)~ 
else ~elseStmt~~endif~ >>

ForStmt(update,initialization,compare,body) ::= <<for (~initialization:{it|~it~};separator=", "~; ~compare~; ~update:{it|~it~};separator=", "~) ~body~ >>

DoStmt(condition,body) ::= <<do ~body~ while (~condition~); >>

ExplicitConstructorInvocationStmt(isThis,arguments) ::= <<~if(isThis)~this~else~super~endif~(~arguments:{it|~it~};separator=", "~); >>

TryStmt(tryBlock,finalClause,catchClauses,resources) ::= <<try~if(resources)~ (~resources:{it|~it~};separator=";"~)~endif~ ~tryBlock~ ~catchClauses:{it|~it~}~~if(finalClause)~ finally ~finalClause~~endif~ >>

CatchClause(parameter,body) ::= <<catch (~parameter~) ~body~ >>

Types() ::= << >>

TypeParameter(name,typeBounds) ::= <<~name~~if(typeBounds)~ extends ~typeBounds:{it|~it~};separator=" & "~~endif~ >>

ClassOrInterfaceType(scope,names,typeArguments,isTyped,isArrayType) ::= <<~if(scope)~~scope~.~endif~~names:{it|~it~};separator=" | "~~if(typeArguments)~<~typeArguments:{it|~it~};separator=", "~>~else~~if(isTyped)~<>~endif~~endif~~if(isArrayType)~[]~endif~ >>

ArrayCreationLevel(dimension) ::= <<[~dimension~] >>

QualifierName(value) ::= <<~value:{it|~it~};separator="."~ >>

JavaPackageInfo(packageName,interfaces,classes) ::= <<~packageName~

interfaces:
	~interfaces:{it|~it.name~};separator="\n"~

classes:
	~classes:{it|~it.name~};separator="\n"~ >>

MemberValuePair(name,value) ::= <<~name~ = ~value~ >>

JavaTypes() ::= << >>

ArrayList(type) ::= <<java.util.ArrayList<~type~> >>

List(type) ::= <<java.util.List<~type~> >>

FileType() ::= <<java.io.File >>

Patterns() ::= << >>

NewInstance(type,arguments) ::= <<new ~type~(~arguments:{it|~it~};separator=","~) >>

eom() ::= "}"

gt() ::= ">"
