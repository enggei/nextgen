delimiters "~","~"

Expressions() ::= << >>

NullExpression() ::= <<null  >>

CastExpression(expression,type) ::= <<~expression~ as ~type~  >>

FunctionCallExpression(scope,functionName,arguments) ::= <<~if(scope)~~scope~.~endif~~functionName~(~arguments:{it|~it~};separator=", "~)  >>

ThisExpression(expression) ::= <<this.~expression~  >>

ConstructorCallExpression(className,params) ::= <<~className~(~params:{it|~it~};separator=", "~)  >>

ArrayEqualsExpression(leftArray,rightArray) ::= <<~leftArray~.contentEquals(~rightArray~)  >>

ScopeExpression(scope,expression) ::= <<~scope~.~expression~  >>

PairExpression(first,second) ::= <<~first~ to ~second~  >>

LiteralExpression(literal) ::= <<~literal~  >>

StringValueExpression(literal) ::= <<"~literal~"  >>

AssignExpression(varName,operator,expression) ::= <<~varName~ ~operator~ ~expression~  >>

ObjectExpression(extends,fields,members) ::= <<object~if(extends)~ : ~extends:{it|~it~};separator=", "~~endif~ {
	~fields:{it|~it~};separator="\n"~

	~members:{it|~it~};separator="\n"~
}  >>

ReferenceExpression(scope,name,property) ::= <<~if(scope)~~scope~.~endif~~name~::~property~  >>

PropertyAccessorExpression(object,property) ::= <<~object~.~property~  >>

RawStringExpression(rawString) ::= <<"""~rawString~"""  >>

AssertNotNullExpression(expression) ::= <<!!~expression~  >>

GroupedExpression(expression) ::= <<(~expression~)  >>

LogicalExpression(lhs,operator,rhs) ::= <<~lhs~ ~operator~ ~rhs~  >>

IfExpression(logicalExpression,whenTrue,whenFalse) ::= <<if(~logicalExpression~) ~whenTrue~ else ~whenFalse~  >>

ComparisonExpression(lhs,operator,rhs) ::= <<~lhs~ ~operator~ ~rhs~  >>

EscapedLiteralExpression(literal) ::= <<`~literal~`  >>

Grammar() ::= << >>

Declarations() ::= << >>

AnnotationDeclaration(scope,name,params) ::= <<@~if(scope)~~scope~.~endif~~name~~if(params)~(~params:{it|~it~};separator=", "~)~endif~  >>

PackageDeclaration(name) ::= <<package ~name~ >>

ClassDeclaration(comments,annotations,isOpen,isAbstract,name,fields,extends,properties,companionObject,subclasses,overrideEquals,overrideHashCode,overrideToString,members) ::= <<~comments~
~annotations:{it|~it~};separator="\n"~
~if(isOpen)~open ~elseif(isAbstract)~abstract ~endif~class ~name~~if(fields)~(
	~fields:{it|~it~};separator=",\n"~
)~endif~~if(extends)~ : ~extends:{it|~it~};separator=", "~~endif~ {

	~properties:{it|~it~};separator="\n\n"~
	~companionObject~

	~subclasses:{it|~it~};separator="\n\n"~

	~overrideEquals~

	~overrideHashCode~

	~overrideToString~

	~members:{it|~it~};separator="\n\n"~
}  >>

OverrideEquals(className,fields) ::= <<override fun equals(other: Any?): Boolean {
	if (other !is ~className~) return false
	return if (other === this) true
	else
		~fields:{it|~it~};separator=" && "~
}  >>

OverrideHashCode(returnStatement) ::= <<override fun hashCode(): Int {
	~returnStatement~
}  >>

OverrideToString(className,fields) ::= <<override fun toString(): String {
	return "~className~(~fields:{it|~it.name~=~it.output~};separator=", "~)"
}  >>

CompanionObject(objectDeclaration) ::= <<companion ~objectDeclaration~  >>

PropertyDeclaration(annotations,isAbstract,override,isPrivate,isProtected,isMutable,name,type,initializer,privateSetter) ::= <<~annotations:{it|~it~};separator="\n"~
~if(isAbstract)~abstract ~endif~~if(override)~override ~endif~~if(isPrivate)~private ~elseif(isProtected)~protected ~endif~~if(isMutable)~var ~else~val ~endif~~name~~if(type)~: ~type~~endif~~if(initializer)~ = ~initializer~~endif~~if(privateSetter)~
	private set~endif~  >>

FunctionDeclaration(annotations,override,name,params,returnType,expressionBody,statements) ::= <<~annotations:{it|~it~};separator="\n"~
~if(override)~override ~endif~fun ~name~(~params:{it|~it~};separator=", "~)~if(returnType)~: ~returnType~~endif~~if(expressionBody)~ =
	~expressionBody~~else~~if(statements)~ {
	~statements:{it|~it~};separator="\n"~
}~endif~~endif~  >>

FunctionParam(name,typeDeclaration,defaultValue) ::= <<~name~: ~typeDeclaration~~if(defaultValue)~ = ~defaultValue~~endif~  >>

DataClassDeclaration(comments,annotations,name,fields,members,subclasses) ::= <<~comments~
~annotations:{it|~it~};separator="\n"~
data class ~name~(
	~fields:{it|~it~};separator=",\n"~
)~if(members)~ {

	~members:{it|~it~};separator="\n"~

	~subclasses:{it|~it~};separator="\n"~
}~endif~  >>

ExtendingClass(name,params) ::= <<~name~(~params:{it|~it~};separator=", "~)  >>

ImplementingInterface(type) ::= <<~type~  >>

InterfaceDeclaration(comments,name,extends,members,properties) ::= <<~comments~
interface ~name~~if(extends)~: ~extends:{it|~it~};separator=", "~~endif~~if(members)~ { ~elseif(properties)~ {~endif~

	~properties:{it|~it~};separator="\n\n"~
	~members:{it|~it~};separator="\n\n"~
~if(members)~}~elseif(properties)~}~endif~  >>

ParameterDeclaration(name,type,initializer) ::= <<~name~~if(type)~: ~type~~endif~~if(initializer)~ = ~initializer~~endif~  >>

ObjectDeclaration(name,extends,fields,members) ::= <<object~if(name)~ ~name~~endif~~if(extends)~ : ~extends:{it|~it~};separator=", "~~endif~ {
	~fields:{it|~it~};separator="\n"~

	~members:{it|~it~};separator="\n"~
}  >>

EnumClassDeclaration(comments,name,params,values) ::= <<~comments~
enum class ~name~~if(params)~(~params:{it|~it~};separator=", "~)~endif~ {
	~values:{it|~it~};separator=",\n"~
}  >>

EnumField(name,inputs) ::= <<~name~~if(inputs)~(~inputs:{it|~it~};separator=", "~)~endif~  >>

Statements() ::= << >>

ImportStatement(scope,name) ::= <<import ~scope~.~name~  >>

TodoStatement(reason) ::= <<TODO("~reason~")  >>

ReturnStatement(expression) ::= <<return ~expression~  >>

VarDeclarationStatement(isMutable,name,type,initializer) ::= <<~if(isMutable)~var ~else~val ~endif~~name~~if(type)~: ~type~~endif~~if(initializer)~ = ~initializer~~endif~  >>

IfStatement(logicalExpression,statements) ::= <<if(~logicalExpression~) {
	~statements:{it|~it~};separator="\n"~
}  >>

CommentBlock(comment) ::= <</*
~comment~
*/  >>

SingleLineComment(comment) ::= <<// ~comment~  >>

KotlinStringTemplates() ::= << >>

KotlinStringTemplateExpression(expression) ::= <<${~expression~}  >>

KotlinStringTemplateSingleValue(name) ::= <<$~name~  >>

Initializers() ::= << >>

ArrayInitializer(expressions) ::= <<arrayOf(~expressions:{it|~it~};separator=", "~)  >>

EmptyArrayInitializer() ::= <<emptyArray()  >>

ListInitializer(expressions) ::= <<listOf(~expressions:{it|~it~};separator=", "~)  >>

MapInitializer(kvpairs) ::= <<mapOf(~kvpairs:{it|~it.key~ to ~it.value~};separator=", "~)  >>

EmptyMapInitializer() ::= <<emptyMap()  >>

MutableMapInitializer(kvpairs) ::= <<mutableMapOf(~kvpairs:{it|~it.key~ to ~it.value~};separator=", "~)  >>

SetInitializer(expressions) ::= <<setOf(~expressions:{it|~it~};separator=", "~)  >>

MutableSetInitializer(expressions) ::= <<mutableSetOf(~expressions:{it|~it~};separator=", "~)  >>

MutableListInitializer(expressions) ::= <<mutableListOf(~expressions:{it|~it~};separator=", "~)  >>

KotlinFile(packageDeclaration,imports,compilationUnit) ::= <<~packageDeclaration~

~imports:{it|~it~};separator="\n"~

~compilationUnit:{it|~it~};separator="\n\n"~  >>

KotlinTypes() ::= << >>

ArrayType(type) ::= <<Array<~type~>  >>

ListType(type) ::= <<List<~type~>  >>

MapType(first,second) ::= <<Map<~first~, ~second~>  >>

NamedType(name) ::= <<~name~  >>

NullableType(type) ::= <<~type~?  >>

StringType() ::= <<String  >>

IntType() ::= <<Int  >>

LongType() ::= <<Long  >>

BooleanType() ::= <<Boolean  >>

FloatType() ::= <<Float  >>

DoubleType() ::= <<Double  >>

UnitType() ::= <<Unit  >>

PairType(first,second) ::= <<Pair<~first~, ~second~>  >>

MutableMapType(first,second) ::= <<MutableMap<~first~, ~second~>  >>

MutableListType(type) ::= <<MutableList<~type~>  >>

SetType(type) ::= <<Set<~type~>  >>

MutableSetType(type) ::= <<MutableSet<~type~>  >>

AnyType() ::= <<Any  >>

TemplateType(name,templates) ::= <<~name~<~templates:{it|~it~};separator=", "~>  >>

StarType() ::= <<*  >>

eom() ::= "}"

gt() ::= ">"
