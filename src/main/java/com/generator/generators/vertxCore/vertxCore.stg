/* uuid : d1664336-9777-4cc9-9772-c3a974bcc4bb */
delimiters "~", "~"

/** name,STRINGPROPERTY;packageName,STRINGPROPERTY;statement,STRINGPROPERTY; **/
MessageHandlerVerticle(name,packageName,statement) ::= <<
 package ~packageName~;

import com.generator.util.VertxUtil;
import io.vertx.core.AbstractVerticle;
import io.vertx.core.Handler;
import io.vertx.core.eventbus.Message;
import io.vertx.core.json.JsonObject;

public class ~name~ extends AbstractVerticle implements Handler<Message<Object~bugfix()~> {

	private final static org.apache.log4j.Logger log = org.apache.log4j.Logger.getLogger(NodeMessageHandler.class);

	@Override
	public void handle(Message<Object> objectMessage) {
		log.info("handle " + objectMessage.body());
		~statement~
	}
} 
>>

/** result,STRINGPROPERTY;resultHandler,STRINGPROPERTY;statements,LISTPROPERTY; **/
blockingCode(result,resultHandler,statements) ::= <<
 vertx.executeBlocking(future -> {

    ~statements:{it|~it~;};separator="\n"~

    future.complete(~result~);

}, res -> {
    ~resultHandler~
}) 
>>

/** client,STRINGPROPERTY;content,STRINGPROPERTY;handleBody,STRINGPROPERTY;handleResponse,STRINGPROPERTY;headers,KEYVALUELISTPROPERTY,name,value;httpMethod,STRINGPROPERTY;uri,STRINGPROPERTY; **/
clientRequest(client,content,handleBody,handleResponse,headers,httpMethod,uri) ::= <<
 final HttpClientRequest request = ~client~.request(HttpMethod.~httpMethod~, ~uri~, resp -> {

    ~handleResponse~

    resp.bodyHandler(body -> {
        ~handleBody~
    });
});

request~headers:{it|.
    putHeader("~it.name~", ~it.value~)}~.
    end(~content~); 
>>

/** onFail,STRINGPROPERTY;onSuccess,STRINGPROPERTY;options,STRINGPROPERTY;reference,STRINGPROPERTY;type,STRINGPROPERTY; **/
deployVerticleProgrammatically(onFail,onSuccess,options,reference,type) ::= <<
 Verticle ~reference~ = new ~type~();
vertx.deployVerticle(~reference~, ~options~, res -> {
    if (res.succeeded()) {
        ~onSuccess~
    } else {
        ~onFail~
    }
}); 
>>

/** config,STRINGPROPERTY;name,STRINGPROPERTY;onSuccess,STRINGPROPERTY; **/
deployVerticleStart(config,name,onSuccess) ::= <<
 vertx.deployVerticle("~name~", new io.vertx.core.DeploymentOptions()~if(config)~.
                                   setConfig(~config~)~endif~, res -> {
    if (res.succeeded()) {
        ~onSuccess~
        startFuture.complete();
    } else {
        startFuture.fail(res.cause());
    }
}) 
>>

/** address,STRINGPROPERTY;onMessage,STRINGPROPERTY; **/
ebConsume(address,onMessage) ::= <<
 vertx.eventBus().consumer("~address~", message -> {
    ~onMessage~
}); 
>>

/** address,STRINGPROPERTY;value,STRINGPROPERTY; **/
ebPublish(address,value) ::= <<
 vertx.eventBus().publish("~address~", ~value~); 
>>

/** name,STRINGPROPERTY;reference,STRINGPROPERTY; **/
getInteger(name,reference) ::= <<
 ~reference~.getInteger("~name~")
// change template to getInteger 
>>

/** name,STRINGPROPERTY;reference,STRINGPROPERTY;type,STRINGPROPERTY; **/
getJson(name,reference,type) ::= <<
 ~reference~.get~type~("~name~") 
>>

/** name,STRINGPROPERTY;reference,STRINGPROPERTY; **/
getString(name,reference) ::= <<
 ~reference~.getString("~name~")
// change template to getString 
>>

/** clientOptions,STRINGPROPERTY;reference,STRINGPROPERTY; **/
httpClient(clientOptions,reference) ::= <<
 io.vertx.core.http.HttpClient ~reference~ = vertx.createHttpClient(~clientOptions~) 
>>

/** connectTimeout,STRINGPROPERTY;defaultHost,STRINGPROPERTY;defaultPort,STRINGPROPERTY;idleTimeout,STRINGPROPERTY;keepAlive,STRINGPROPERTY;keyStoreOptions,STRINGPROPERTY;maxPoolSize,STRINGPROPERTY;maxWebsocketFrameSize,STRINGPROPERTY;pemKeyCertOptions,STRINGPROPERTY;pemTrustOptions,STRINGPROPERTY;pfxKeycertOptions,STRINGPROPERTY;pfxTrustOptions,STRINGPROPERTY;pipelining,STRINGPROPERTY;protocolVersion,STRINGPROPERTY;receiveBufferSize,STRINGPROPERTY;reference,STRINGPROPERTY;reuseAddress,STRINGPROPERTY;sendBufferSize,STRINGPROPERTY;soLinger,STRINGPROPERTY;ssl,STRINGPROPERTY;tcpKeepAlive,STRINGPROPERTY;tcpNoDelay,STRINGPROPERTY;trafficClass,STRINGPROPERTY;trustAll,STRINGPROPERTY;trustStore,STRINGPROPERTY;tryUseCompression,STRINGPROPERTY;usePooledBuffers,STRINGPROPERTY;verifyHost,STRINGPROPERTY; **/
httpClientOptions(connectTimeout,defaultHost,defaultPort,idleTimeout,keepAlive,keyStoreOptions,maxPoolSize,maxWebsocketFrameSize,pemKeyCertOptions,pemTrustOptions,pfxKeycertOptions,pfxTrustOptions,pipelining,protocolVersion,receiveBufferSize,reference,reuseAddress,sendBufferSize,soLinger,ssl,tcpKeepAlive,tcpNoDelay,trafficClass,trustAll,trustStore,tryUseCompression,usePooledBuffers,verifyHost) ::= <<
 ~if(reference)~io.vertx.core.http.HttpClientOptions options = ~endif~new io.vertx.core.http.HttpClientOptions()
    ~if(connectTimeout)~.setConnectTimeout(~connectTimeout~)/* Set the connect timeout */ ~endif~
    ~if(defaultHost)~.setDefaultHost(~defaultHost~)/* Set the default host name to be used by this client in requests if none is provided when making the request. */ ~endif~
    ~if(defaultPort)~.setDefaultPort(~defaultPort~)/* Set the default port to be used by this client in requests if none is provided when making the request. */ ~endif~
    ~if(idleTimeout)~.setIdleTimeout(~idleTimeout~)/* Set the idle timeout, in seconds. */ ~endif~
    ~if(keepAlive)~.setKeepAlive(~keepAlive~)/* Set whether keep alive is enabled on the client */ ~endif~
    ~if(keyStoreOptions)~.setKeyStoreOptions(~keyStoreOptions~)/* Set the key/cert options in jks format, aka Java keystore. */ ~endif~
    ~if(maxPoolSize)~.setMaxPoolSize(~maxPoolSize~)/* Set the maximum pool size for connections */ ~endif~
    ~if(maxWebsocketFrameSize)~.setMaxWebsocketFrameSize(~maxWebsocketFrameSize~)/* Set the max websocket frame size */ ~endif~
    ~if(pemKeyCertOptions)~.setPemKeyCertOptions(~pemKeyCertOptions~)/* Set the key/cert store options in pem format. */ ~endif~
    ~if(pemTrustOptions)~.setPemTrustOptions(~pemTrustOptions~)/* Set the trust options in pem format */ ~endif~
    ~if(pfxKeycertOptions)~.setPfxKeyCertOptions(~pfxKeycertOptions~)/* Set the key/cert options in pfx format. */ ~endif~
    ~if(pfxTrustOptions)~.setPfxTrustOptions(~pfxTrustOptions~)/* Set the trust options in pfx format */ ~endif~
    ~if(pipelining)~.setPipelining(~pipelining~)/* Set whether pipe-lining is enabled on the client */ ~endif~
    ~if(protocolVersion)~.setProtocolVersion(~protocolVersion~)/* Set the protocol version. */ ~endif~
    ~if(receiveBufferSize)~.setReceiveBufferSize(~receiveBufferSize~)/* Set the TCP receive buffer size */ ~endif~
    ~if(reuseAddress)~.setReuseAddress(~reuseAddress~)/* Set the value of reuse address */ ~endif~
    ~if(sendBufferSize)~.setSendBufferSize(~sendBufferSize~)/* Set the TCP send buffer size */ ~endif~
    ~if(soLinger)~.setSoLinger(~soLinger~)/* Set whether SO_linger keep alive is enabled */ ~endif~
    ~if(ssl)~.setSsl(~ssl~)/* Set whether SSL/TLS is enabled */ ~endif~
    ~if(tcpKeepAlive)~.setTcpKeepAlive(~tcpKeepAlive~)/* Set whether TCP keep alive is enabled */ ~endif~
    ~if(tcpNoDelay)~.setTcpNoDelay(~tcpNoDelay~)/* Set whether TCP no delay is enabled */ ~endif~
    ~if(trafficClass)~.setTrafficClass(~trafficClass~)/* Set the value of traffic class */ ~endif~
    ~if(trustAll)~.setTrustAll(~trustAll~)/* Set whether all server certificates should be trusted */ ~endif~
    ~if(trustStore)~.setTrustStoreOptions(~trustStore~)/* Set the trust options in jks format, aka Java trustore */ ~endif~
    ~if(tryUseCompression)~.setTryUseCompression(~tryUseCompression~)/* Set whether compression is enabled */ ~endif~
    ~if(usePooledBuffers)~.setUsePooledBuffers(~usePooledBuffers~)/* Set whether Netty pooled buffers are enabled */ ~endif~
    ~if(verifyHost)~.setVerifyHost(~verifyHost~)/* Set whether hostname verification is enabled */ ~endif~ 
>>

/** reference,STRINGPROPERTY;values,KEYVALUELISTPROPERTY,key,value; **/
json(reference,values) ::= <<
 ~if(reference)~final io.vertx.core.json.JsonObject ~reference~ = ~endif~new io.vertx.core.json.JsonObject()~values:{it|.
    put("~it.key~",~it.value~)}~ 
>>

/** reference,STRINGPROPERTY;string,STRINGPROPERTY; **/
jsonFromString(reference,string) ::= <<
 ~if(reference)~final io.vertx.core.json.JsonObject ~reference~ = ~endif~new io.vertx.core.json.JsonObject(~string~) 
>>

/** ms,STRINGPROPERTY;reference,STRINGPROPERTY;statements,LISTPROPERTY; **/
periodicTimer(ms,reference,statements) ::= <<
 long ~reference~ = vertx.setPeriodic(~ms~, id -> {
  ~statements:{it|~it~;}; separator="\n\n"~
}); 
>>

/** statements,LISTPROPERTY; **/
runinContext(statements) ::= <<
 vertx.getOrCreateContext().runOnContext( (v) -> {
    ~statements:{it|~it~;};separator="\n\n"~
}); 
>>

/** fields,LISTPROPERTY;imports,LISTPROPERTY;name,STRINGPROPERTY;packageName,STRINGPROPERTY;startStatements,LISTPROPERTY;stopStatements,LISTPROPERTY;verticles,KEYVALUELISTPROPERTY,deploy; **/
verticle(fields,imports,name,packageName,startStatements,stopStatements,verticles) ::= <<
 package ~packageName~;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.http.HttpClient;
import io.vertx.core.http.HttpClientOptions;
import io.vertx.core.http.HttpClientRequest;
import io.vertx.core.http.HttpMethod;
import io.vertx.core.json.JsonObject;

~imports:{it | import ~it~;}; separator="\n"~

public class ~name~ extends AbstractVerticle {

    private final static org.apache.log4j.Logger log = org.apache.log4j.Logger.getLogger(~name~.class);

    ~fields:{it|~it~;};separator="\n"~

    @Override
    public void start(Future<Void> startFuture) throws Exception {

        ~startStatements:{it|~it~;};separator="\n"~

        ~verticles:{it|~it.deploy~};separator="\n\n"~
    }

    @Override
    public void stop(Future<Void> stopFuture) throws Exception {
        ~stopStatements:{it|~it~};separator="\n"~
    }
} 
>>

/** options,STRINGPROPERTY;reference,STRINGPROPERTY; **/
vertx(options,reference) ::= <<
 Vertx ~reference~ = Vertx.vertx(~if(options)~~options~~endif~); 
>>

/** blockedThreadCheckInterval,STRINGPROPERTY;clusterHost,STRINGPROPERTY;clusterManager,STRINGPROPERTY;clusterPingInterval,STRINGPROPERTY;clusterPingReplyInterval,STRINGPROPERTY;clusterPort,STRINGPROPERTY;clusterPublicHost,STRINGPROPERTY;clusterPublicPort,STRINGPROPERTY;clustered,STRINGPROPERTY;eventLoopPoolSize,STRINGPROPERTY;haEnabled,STRINGPROPERTY;haGroup,STRINGPROPERTY;internalBlockingPoolSize,STRINGPROPERTY;maxEventLoopExecuteTime,STRINGPROPERTY;maxWorkerExecuteTime,STRINGPROPERTY;metrics,STRINGPROPERTY;quorumSize,STRINGPROPERTY;warningExceptionTime,STRINGPROPERTY;workerPoolSize,STRINGPROPERTY; **/
vertxOptions(blockedThreadCheckInterval,clusterHost,clusterManager,clusterPingInterval,clusterPingReplyInterval,clusterPort,clusterPublicHost,clusterPublicPort,clustered,eventLoopPoolSize,haEnabled,haGroup,internalBlockingPoolSize,maxEventLoopExecuteTime,maxWorkerExecuteTime,metrics,quorumSize,warningExceptionTime,workerPoolSize) ::= <<
 new VertxOptions()
    ~if(blockedThreadCheckInterval)~.setBlockedThreadCheckInterval(~blockedThreadCheckInterval~)  /* Sets the value of blocked thread check period, in ms. */ ~endif~
    ~if(clustered)~.setClustered(~clustered~) /* Set whether or not the Vert.x instance will be clustered. */ ~endif~
    ~if(clusterHost)~.setClusterHost(~clusterHost~) /* Set the hostname to be used for clustering. */ ~endif~
    ~if(clusterManager)~.setClusterManager(~clusterManager~) /* Programmatically set the cluster manager to be used when clustering. */ ~endif~
    ~if(clusterPingInterval)~.setClusterPingInterval(~clusterPingInterval~) /* Set the value of cluster ping interval, in ms. */ ~endif~
    ~if(clusterPingReplyInterval)~.setClusterPingReplyInterval(~clusterPingReplyInterval~) /* Set the value of cluster ping reply interval, in ms. */ ~endif~
    ~if(clusterPort)~.setClusterPort(~clusterPort~) /* Set the port to be used for clustering. */ ~endif~
    ~if(clusterPublicHost)~.setClusterPublicHost(~clusterPublicHost~) /* Set the public facing hostname to be used for clustering. */ ~endif~
    ~if(clusterPublicPort)~.setClusterPublicPort(~clusterPublicPort~) /* See setClusterPublicHost(String) for an explanation. */ ~endif~
    ~if(eventLoopPoolSize)~.setEventLoopPoolSize(~eventLoopPoolSize~) /* Set the number of event loop threads to be used by the Vert.x instance. */ ~endif~
    ~if(haEnabled)~.setHAEnabled(~haEnabled~) /* Set whether HA will be enabled on the Vert.x instance. */ ~endif~
    ~if(haGroup)~.setHAGroup(~haGroup~) /* Set the HA group to be used when HA is enabled. */ ~endif~
    ~if(internalBlockingPoolSize)~.setInternalBlockingPoolSize(~internalBlockingPoolSize~) /* Set the value of internal blocking pool size */ ~endif~
    ~if(maxEventLoopExecuteTime)~.setMaxEventLoopExecuteTime(~maxEventLoopExecuteTime~) /* Sets the value of max event loop execute time, in ns. */ ~endif~
    ~if(maxWorkerExecuteTime)~.setMaxWorkerExecuteTime(~maxWorkerExecuteTime~) /* Sets the value of max worker execute time, in ns. */ ~endif~
    ~if(metrics)~.setMetricsOptions(~metrics~) /* Set the metrics options */ ~endif~
    ~if(quorumSize)~.setQuorumSize(~quorumSize~) /* Set the quorum size to be used when HA is enabled. */ ~endif~
    ~if(warningExceptionTime)~.setWarningExceptionTime(~warningExceptionTime~) /* Set the threshold value above this, the blocked warning contains a stack trace. */ ~endif~
    ~if(workerPoolSize)~.setWorkerPoolSize(~workerPoolSize~) /* Set the maximum number of worker threads to be used by the Vert.x instance. */ ~endif~ 
>>
