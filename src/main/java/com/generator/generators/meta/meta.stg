/* meta d7edfa85-3b26-4035-b712-15db0af3094a*/
delimiters "~", "~"

eom() ::= <<}>>

gt() ::= <<> >>

DomainClass(domainName,entities,packageName,properties,relations) ::= <<package ~packageName~;

import com.generator.domain.IDomain;
import com.generator.editors.BaseDomainVisitor;
import com.generator.editors.NeoModel;
import com.generator.editors.canvas.neo.NeoEditor;
import com.generator.editors.canvas.neo.NeoPNode;
import com.generator.util.SwingUtil;
import org.neo4j.graphdb.Label;
import org.neo4j.graphdb.*;
import org.piccolo2d.event.PInputEvent;
import org.piccolo2d.nodes.PText;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.util.*;
import java.util.function.Consumer;

import static com.generator.editors.BaseDomainVisitor.*;
import static com.generator.editors.NeoModel.getNameOrLabelFrom;
import static com.generator.editors.NeoModel.uuidOf;
import static ~packageName~.~domainName~Domain.Entities.*;
import static ~packageName~.~domainName~Domain.Relations.*;
import static org.neo4j.graphdb.Direction.INCOMING;

/**
 * Created 23.02.17.
 */
public abstract class ~domainName~Domain implements IDomain {

   public enum Entities implements Label {
      ~entities:{it|~it.name~};separator=", "~
   }

   public enum Relations implements RelationshipType {
      ~relations:{it|~it.name;format="toUpper"~};separator=", "~
   }

   public enum Properties {
      ~properties:{it|~it.name~};separator=", "~
   }

   @Override
   public String getName() {
      return "~domainName~";
   }

   @Override
   public final Label[] values() {
      return Entities.values();
   }

   @Override
   public final NeoPNode newPNode(Node node, String nodetype, NeoEditor editor) {
      switch (Entities.valueOf(nodetype)) {
         ~entities:{it|case ~it.name~:
	return new~it.name;format="capitalize"~PNode(node, editor);};separator="\n"~
      }

      throw new IllegalArgumentException("unsupported ~domainName~Domain nodetype " + nodetype + " for node " + NeoModel.debugNode(node));
   }

	@Override
   public void deleteNode(Node node) throws NeoEditor.ReferenceException {
      // todo enforce constraints
      final Set<Relationship> constraints = new LinkedHashSet<>();

      final Consumer<Relationship> constraintVisitor = relationship -> {
         if (NeoEditor.isAppRelated(relationship)) return;
         constraints.add(relationship);
      };

      //if (node.hasLabel(ContextProperty)) {
         //node.getRelationships(INCOMING, PROPERTY).forEach(Relationship::delete);
         //node.getRelationships(INCOMING, FROM).forEach(Relationship::delete);
      //}

      // delete from layouts:
      NeoEditor.removeFromLayouts(node);

      node.delete();
   }

~entities:{it|
   ~it.declaration~
};separator="\n"~

   private static class ~domainName~DomainPNode extends NeoPNode<PText> {

      final Color selectedColor = Color.RED;
      private final Color defaultColor;
      private final String property;
      private final ~domainName~Domain.Entities nodeType;

      ~domainName~DomainPNode(Node node, ~domainName~Domain.Entities nodeType, String property, String defaultColor, NeoEditor editor) {
         super(node, new PText(node.hasProperty(property) ? node.getProperty(property).toString() : getNameOrLabelFrom(node)), nodeType.name(), editor);
         this.defaultColor = defaultColor==null || defaultColor.length()==0 ? Color.BLACK : Color.decode(defaultColor);
         this.property = property;
         this.nodeType = nodeType;
         pNode.setTextPaint(this.defaultColor);
         pNode.setFont(new Font("Hack", Font.BOLD, 12));
      }

      @Override
      public String getNodeType() {
         return nodeType.name();
      }

      @Override
      public void expand() {

      }

      @Override
      public void showDependents() {

      }

      @Override
      public void keyPressed(PInputEvent event) {
         super.keyPressed(event);
      }

      @Override
      public void updateView() {
         if (property == null) System.out.println("override updateView: property not set");
			pNode.setText(property == null ? "?" : node.hasProperty(property) ? node.getProperty(property).toString() : getNameOrLabelFrom(node));
      }

      @Override
      public void onSelect() {
         pNode.setTextPaint(selectedColor);
      }

      @Override
      public void onUnselect() {
         pNode.setTextPaint(defaultColor);
      }

      @Override
      public void onStartHighlight() {
         pNode.setTextPaint(Color.ORANGE);
      }

      @Override
      public void onEndHighlight() {
         pNode.setTextPaint(selected.get() ? selectedColor : defaultColor);
      }

      @Override
      public void showNodeActions(JPopupMenu pop, PInputEvent event) {

         editor.showDeleteOutgoingRelations(pop, node);

         pop.add(new NeoEditor.TransactionAction("Select all " + nodeType, editor) {
            @Override
            public void actionPerformed(ActionEvent e, Transaction tx) throws Exception {
               editor.getAllNodes().forEach(neoPNode -> {
                  if (neoPNode.getNodeType().equals(nodeType.name()) && !neoPNode.selected.get())
                     neoPNode.select();
               });
            }
         });
         pop.add(new NeoEditor.TransactionAction("Hide all " + nodeType, editor) {
            @Override
            public void actionPerformed(ActionEvent e, Transaction tx) throws Exception {
               final Set<UUID> hide = new LinkedHashSet<>();
               editor.getAllNodes().forEach(pNode -> {
                  if (pNode.getNodeType().equals(nodeType.name())) hide.add(pNode.uuid);
               });
               hide.forEach(editor::removeNodeFromCanvas);
            }
         });

         pop.add(retainNode());
         pop.add(hideNode());
         pop.add(deleteNode());
      }
   }

	~entities:{it|~it.editor~};separator="\n\n"~

	~relations:{it|~it.editor~};separator="\n\n"~

   public static abstract class ~domainName~DomainVisitor implements com.generator.domain.IDomainVisitor {

		@Override
      public <T> T visit(Node n) {
         if (n == null) return null;
		  ~entities:{it|if (BaseDomainVisitor.hasLabel(n, ~it.name~.name())) return visit~it.name;format="capitalize"~(n);};separator="\n"~
         return null;
      }

~entities:{it|
		<T> T visit~it.name;format="capitalize"~(Node node) {
         return null;
      ~eom()~
};separator="\n"~
   }
}>>

PropertyEditor(name,properties) ::= <<~if(properties)~
static class ~name;format="capitalize"~PropertyEditor extends SwingUtil.FormPanel {

		~properties:{it|private final ~it.component~ _~it.name~ = new ~it.component~();};separator="\n"~

      ~name;format="capitalize"~PropertyEditor(PropertyContainer container) {
         super("50dlu, 4dlu, 350dlu", "~properties:{it|pref, 4dlu};separator=", "~");

         int row = -1;
~properties:{it|
         row += 2;
         addLabel("~it.name;format="capitalize"~", 1, row);
         add(_~it.name~, 3, row);
			setValue(_~it.name~, container, Properties.~it.name~.name(), ~it.enums~);
};separator="\n"~
      }

		private void setValue(JTextField component, PropertyContainer container, String property, String[] values) {
         component.setText(container.hasProperty(property) ? getString(container, property) : "");
      }

		private void setValue(JCheckBox component, PropertyContainer container, String property, String[] values) {
         component.setSelected(container.hasProperty(property) ? getString(container, property).toLowerCase().startsWith("boo") : false);
      }

      private void setValue(JComboBox<String> component, PropertyContainer container, String property, String[] values) {
         component.setModel(new DefaultComboBoxModel<>(values));
       	final String value = container.hasProperty(property) ? getString(container, property) : null;
	      if (value == null) return;
	      component.setSelectedItem(value);
	   }

      void commit(PropertyContainer container) throws Exception {
			~properties:{it|getValue(container, "~it.name~", _~it.name~); };separator="\n"~
      }

		private void getValue(PropertyContainer container, String property, JTextField component) {
         container.setProperty(property, component.getText().trim());
      }

      private void getValue(PropertyContainer container, String property, JComboBox<String> component) {
         container.setProperty(property, component.getSelectedItem() == null ? null : component.getSelectedItem().toString());
      }
   }

static void show~name;format="capitalize"~PropertyEditor(PropertyContainer container, NeoEditor editor, PInputEvent event) {
   final ~name;format="capitalize"~PropertyEditor form = new ~name;format="capitalize"~PropertyEditor(container);
   SwingUtil.showDialogNoDefaultButton(form, editor.canvas, "~name~", () -> {
      editor.doInTransaction(tx1 -> {
         form.commit(container);
      });
   });
}~endif~>>

EntityInterface(entity,packageName,properties,relations) ::= <<package ~packageName~;

/** Interface for ~entity~ */
public interface ~entity;format="capitalize"~ {

	~properties:{it|
   ~it.type~ get~it.name;format="capitalize"~();

   void set~it.name;format="capitalize"~(~it.type~ ~it.name~);

}~
	~relations:{it|
   void add~it.name;format="capitalize"~(~it.type;format="capitalize"~ table);

   java.util.List<~it.type;format="capitalize"~> get~it.name;format="capitalize"~();

   java.util.Iterator<~it.type;format="capitalize"~> iterate~it.name;format="capitalize"~();};separator="\n"~

}>>

PNodeDeclaration(incoming,color,domainName,label,name,outgoing,outgoingWithProperties,properties) ::= <<protected NeoPNode new~name;format="capitalize"~PNode(Node node, NeoEditor editor) {
      return new ~name;format="capitalize"~PNode(node, editor);
   ~eom()~

protected static class ~name;format="capitalize"~PNode extends ~domainName~DomainPNode {

   ~name;format="capitalize"~PNode(Node node, NeoEditor editor) {
      super(node, Entities.~name~, ~if(label)~~domainName~Domain.Properties.~label~.name()~else~"name"~endif~, "~color~", editor);
   ~eom()~

	@Override
	public void showNodeActions(JPopupMenu pop, PInputEvent event) {
		~if(properties)~
		pop.add(new NeoEditor.TransactionAction("Edit", editor) {
			@Override
			public void actionPerformed(ActionEvent e, Transaction tx) throws Exception {
				show~name;format="capitalize"~PropertyEditor(node, editor, event);
			}
		});~endif~

		~properties:{it|pop.add(editor.newSetNodePropertyAction(~domainName~Domain.Properties.~it.name~.name(), this));};separator="\n"~
		~outgoing:{it|pop.add(editor.newAddNodeAction(Entities.~it.dst~, Relations.~it.relation~, this, event));};separator="\n"~

~outgoingWithProperties:{it|
		for (Relationship relationship : outgoing(node, Relations.~it.relation~)) {
            pop.add(new NeoEditor.TransactionAction("Edit " + relationship.getType() + "' -> '" + NeoModel.getNameOrLabelFrom(other(node, relationship)) + "'", editor) {
               @Override
               public void actionPerformed(ActionEvent e, Transaction tx) throws Exception {
                  show~it.name;format="capitalize"~PropertyEditor(relationship, editor, event);
               ~eom()~
         	~eom()~);
         ~eom()~
};separator="\n"~

		super.showNodeActions(pop, event);
	}
	
	@Override
   public void showTargetActions(JPopupMenu pop, PInputEvent event) {

      final Collection<NeoPNode> selectedNodes = editor.getSelectedNodes();
      if (selectedNodes.isEmpty()) return;

      ~if(outgoing)~final Map<String, Set<Node>~gt()~outgoing = new TreeMap<>();~endif~
      ~if(incoming)~final Map<String, Set<Node>~gt()~incoming = new TreeMap<>();~endif~

      selectedNodes.forEach(selectedNode -> {
~if(outgoing)~
         // outgoing
~outgoing:{it|
         if (selectedNode.node.hasLabel(Entities.~it.dst~)) {
            final Set<Node> set = outgoing.computeIfAbsent(Entities.~it.dst~.name(), k -> new LinkedHashSet<>());
            //todo: add constraint and add if allowed (control circular constraints, one-to-many, only-one etc.)
            set.add(selectedNode.node);
			~eom()~
};separator="\n"~
~endif~
~if(incoming)~
         // incoming
~incoming:{it|
         if (selectedNode.node.hasLabel(Entities.~it.src~)) {
            final Set<Node> set = incoming.computeIfAbsent(Entities.~it.src~.name(), k -> new LinkedHashSet<>());
            set.add(selectedNode.node);
			~eom()~
};separator="\n"~
~endif~
      });

~if(outgoing)~
      // outgoing
~outgoing:{it|
      if (outgoing.containsKey(Entities.~it.dst~.name())) {
         final Set<Node> nodes = outgoing.get(Entities.~it.dst~.name());
         pop.add(new NeoEditor.TransactionAction("Add -> " + Relations.~it.relation~, editor) {
            @Override
            public void actionPerformed(ActionEvent e, Transaction tx) throws Exception {
               for (Node dst : nodes) {
                  final Relationship newRelation = node.createRelationshipTo(dst, Relations.~it.relation~);
                  editor.addRelation(newRelation);
               ~eom()~
               updateView();
            ~eom()~
         ~eom()~);
      ~eom()~
};separator="\n"~
~endif~
~if(incoming)~
      // incoming
~incoming:{it|
      if (incoming.containsKey(Entities.~it.src~.name())) {
         final Set<Node> nodes = incoming.get(Entities.~it.src~.name());
         pop.add(new NeoEditor.TransactionAction("Add <- " + Relations.~it.relation~, editor) {
            @Override
            public void actionPerformed(ActionEvent e, Transaction tx) throws Exception {
               for (Node src : nodes) {
                  final Relationship newRelation = src.createRelationshipTo(node, Relations.~it.relation~);
                  editor.addRelation(newRelation);
               ~eom()~
               updateView();
            ~eom()~
         ~eom()~);
      ~eom()~
};separator="\n"~
~endif~
   }

   @Override
   public void expand() {
      final Map<UUID, Label> pNodes = new LinkedHashMap<>();
		~outgoing:{it|outgoing(node, Relations.~it.relation~).forEach(relationship -> pNodes.put(uuidOf(other(node, relationship)), Entities.~it.dst~));};separator="\n"~
      editor.showAndLayout(pNodes, pNode);
   }
		
	@Override
   public void showDependents() {
      final Map<UUID, Label> pNodes = new LinkedHashMap<>();
		~incoming:{it|incoming(node, Relations.~it.relation~).forEach(relationship -> pNodes.put(uuidOf(other(node, relationship)), Entities.~it.src~));};separator="\n"~
      editor.showAndLayout(pNodes, pNode);
   }
}>>