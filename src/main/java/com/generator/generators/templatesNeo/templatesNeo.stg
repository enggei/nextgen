/* uuid : e3e93e2e-8cd2-456e-b26c-8c554866e9ea */
delimiters "~", "~"

/** comments,LISTPROPERTY;name,STRINGPROPERTY;packageName,STRINGPROPERTY;statements,KEYVALUELISTPROPERTY,declaration,name,newInstance; **/
NeoGroupClassDeclaration(comments,name,packageName,statements) ::= <<~if(packageName)~package ~packageName~;

import org.neo4j.graphdb.*;

import java.util.UUID;
import java.util.function.Consumer;

import static com.generator.editors.domain.BaseDomainVisitor.*;
import static ~packageName~.~name~Neo.~name~Labels.*;

~endif~
/**
 * Wraps Neo4j methods based on '~name~.stg' file <br/>
 * ~comments:{it|~it~};separator="\n *"~
 */
public final class ~name~Neo {

	private final GraphDatabaseService graph;

	public enum ~name~Labels implements Label {
		~name~,   	
		~statements:{it|~name~_~it.name~};separator=",\n"~, 
		StringNode
	}

   public ~name~Neo(final GraphDatabaseService graph) {
 		this.graph = graph;
	}

	public interface ~name~NeoAction {

		void doAction(Transaction tx) throws Throwable;

		void exception(Throwable throwable);
	}

	public void doInTransaction(~name~NeoAction committer) {
		try (Transaction tx = graph.beginTx()) {
			try {
				committer.doAction(tx);
				tx.success();
			} catch (Throwable throwable) {
				committer.exception(throwable);
				tx.failure();
			}
		}
	}

   ~statements:{it|~it.newInstance~};separator="\r\n\r\n"~

	~statements:{it|~it.declaration~};separator="\r\n\r\n"~

	~defaultNodeTypes()~
} 
>>

/**  **/
bugfix2() ::= <<} 
>>

/** groupName,STRINGPROPERTY;name,STRINGPROPERTY;properties,KEYVALUELISTPROPERTY,name,relationships,setter; **/
declaration(groupName,name,properties) ::= <<public static final class ~name~Node {

	private final GraphDatabaseService graph;
   private final Node node;
	private final UUID uuid;

~if(properties)~	private enum Parameters implements RelationshipType {
		~properties:{it|~it.name~_param};separator=", "~
	}

	~properties:{it|~if(it.relationships)~
~it.relationships~~endif~}~

	private enum KeyValueLabels implements Label {
		~properties:{it|~if(it.relationships)~~it.name;format="capitalize"~, ~endif~}~
	}

~endif~
	private ~name~Node(final GraphDatabaseService graph) {
		this.graph = graph;
		this.node = graph.createNode(~groupName~_~name~);
		this.node.setProperty("uuid", UUID.randomUUID().toString());
		this.uuid = UUID.fromString(getString(node, "uuid"));
	}

	private ~name~Node(final GraphDatabaseService graph, final Node node) {
		this.graph = graph;
		this.node = node;
		this.uuid = UUID.fromString(getString(node, "uuid"));
	}

	public void delete() throws IllegalStateException {
		if (node.hasRelationship(Direction.INCOMING))
			throw new IllegalStateException(toString() + " has " + node.getDegree(Direction.INCOMING) + " dependent incoming relations. Delete these first.");
		tryToDeleteNode(node);
	}	

	public Node node() {
		return node;
	}

	public UUID getUuid() {
		return uuid;
	}

	@Override
	public boolean equals(Object o) {
		if (this == o) return true;
		if (o == null || getClass() != o.getClass()) return false;
		~name~Node that = (~name~Node) o;
		return uuid.equals(that.uuid);
	}

	@Override
	public int hashCode() {
		return uuid.hashCode();
	}

	@Override
	public String toString() {
		return getClass().getName() + "  " + uuid;
	}

   ~properties:{it|~it.setter~};separator="\n\n"~
} 
>>

/**  **/
defaultNodeTypes() ::= <<public static boolean isStringNode(Node node) {
	return node != null && node.hasLabel(StringNode);
}

// convenience-method for instantiating a new StringNode, and setting the value
public Node newStringNode(String value) {
	if (value==null) throw new IllegalArgumentException("value for newStringNode cannot be null");
	
	final Node node = graph.createNode(StringNode);
	node.setProperty("uuid", UUID.randomUUID().toString());
	return newStringNode(node).setValue(value).node();
}

public static StringNode newStringNode(Node node) {
	if (node==null) throw new IllegalArgumentException("node for newStringNode cannot be null");
	
	final UUID uuid = UUID.fromString(getString(node, "uuid"));

	return new StringNode() {
		@Override
		public StringNode setValue(String value) {
			node.setProperty("value", value);
			return this;
		}

		@Override
		public String getValue() {
			return getString(node, "value");
		}

		@Override
		public Node node() {
			return node;
		}

		@Override
		public UUID getUuid() {
			return uuid;
		}

		@Override
		public boolean equals(Object o) {
			if (this == o) return true;
			if (o == null || getClass() != o.getClass()) return false;
			StringNode that = (StringNode) o;
			return uuid.equals(that.getUuid());
		}

		@Override
		public int hashCode() {
			return uuid.hashCode();
		}

		@Override
		public String toString() {
			return getValue();
		}	
	};
}

public interface StringNode {

	public StringNode setValue(String value);

	public String getValue();

	public Node node();

	public UUID getUuid();
} 
>>

/** kvNames,LISTPROPERTY;propertyName,STRINGPROPERTY;statementName,STRINGPROPERTY; **/
keyValueListSetter(kvNames,propertyName,statementName) ::= <<public interface ~propertyName;format="capitalize"~KeyValue {

	~kvNames:{it|public Node get~it;format="capitalize"~Value();};separator="\n\n"~

	~kvNames:{it|public ~propertyName;format="capitalize"~KeyValue set~it;format="capitalize"~Value(Node value);};separator="\n\n"~

	public Node node();

	public UUID getUuid();
}

public ~statementName~Node add~propertyName;format="capitalize"~Value(~propertyName;format="capitalize"~KeyValue value) {
	this.node.createRelationshipTo(value.node(), Parameters.~propertyName~_param);
   return this;
}

public ~propertyName;format="capitalize"~KeyValue new~propertyName;format="capitalize"~KeyValue() {
	final Node node = graph.createNode(KeyValueLabels.~propertyName;format="capitalize"~);
	node.setProperty("uuid", UUID.randomUUID().toString());
	return new~propertyName;format="capitalize"~KeyValue(node);
}

public static ~propertyName;format="capitalize"~KeyValue new~propertyName;format="capitalize"~KeyValue(Node node) {
	if (node==null) throw new IllegalArgumentException("node for new~propertyName;format="capitalize"~KeyValue cannot be null");
	
	final UUID uuid = UUID.fromString(getString(node, "uuid"));

	return new ~propertyName;format="capitalize"~KeyValue() {
		
		~kvNames:{it|@Override
public Node get~it;format="capitalize"~Value() {
	if (!hasOutgoing(node, ~propertyName;format="capitalize"~Relationships.~it~)) return null;
	return other(node, singleOutgoing(node, ~propertyName;format="capitalize"~Relationships.~it~));
~bugfix2()~

@Override
public ~propertyName;format="capitalize"~KeyValue set~it;format="capitalize"~Value(Node value) {
	if (hasOutgoing(node, ~propertyName;format="capitalize"~Relationships.~it~)) {
		final Relationship outgoing = singleOutgoing(node, ~propertyName;format="capitalize"~Relationships.~it~);
		final Node other = other(node, outgoing);
		outgoing.delete();
		tryToDeleteNode(other);
	~bugfix2()~

	if (value != null)
		node.createRelationshipTo(value, ~propertyName;format="capitalize"~Relationships.~it~);

	return this;
~bugfix2()~
 		};separator="\n"~
		@Override
		public Node node() {
			return node;
		}

		@Override
		public UUID getUuid() {
			return uuid;
		}

		@Override
		public boolean equals(Object o) {
			if (this == o) return true;
			if (o == null || getClass() != o.getClass()) return false;
			StringNode that = (StringNode) o;
			return uuid.equals(that.getUuid());
		}

		@Override
		public int hashCode() {
			return uuid.hashCode();
		}
	};
}

public void forEach~propertyName;format="capitalize"~Value(Consumer<~propertyName;format="capitalize"~KeyValue> consumer) {
	for (Relationship relationship : node.getRelationships(Direction.OUTGOING, Parameters.~propertyName~_param)) {
		consumer.accept(new~propertyName;format="capitalize"~KeyValue(other(node, relationship)));
	}
} 
>>

/** name,STRINGPROPERTY;types,LISTPROPERTY; **/
keyValueRelationships(name,types) ::= <<private enum ~name;format="capitalize"~Relationships implements RelationshipType {
	~types:{it|~it~};separator=", "~
} 
>>

/** propertyName,STRINGPROPERTY;statementName,STRINGPROPERTY; **/
listSetter(propertyName,statementName) ::= <<// ~propertyName~
public ~statementName~Node add~propertyName;format="capitalize"~Value(Node target) {
	if (node == null) return this;
	node.createRelationshipTo(target, Parameters.~propertyName~_param);
   return this;
}

public void forEach~propertyName;format="capitalize"~(Consumer<Node> consumer) {
	for (Relationship relationship : node.getRelationships(Direction.OUTGOING, Parameters.~propertyName~_param))
		consumer.accept(other(node, relationship));
} 
>>

/** groupName,STRINGPROPERTY;name,STRINGPROPERTY; **/
newInstance(groupName,name) ::= <<public static boolean is~name;format="capitalize"~(Node node) {
	return node != null && node.hasLabel(~groupName~_~name~);
}

public ~name~Node new~name;format="capitalize"~() {
	return new ~name~Node(graph);
}

public ~name~Node new~name;format="capitalize"~(Node node) {
	return new ~name~Node(graph, node);
}

public void forEach~name;format="capitalize"~Nodes(Consumer<~name~Node> consumer) {
	graph.findNodes(~groupName~_~name~).
		forEachRemaining(new Consumer<Node>() {
			@Override
			public void accept(Node node) {
				consumer.accept(new ~name~Node(graph, node));
			}
		});
}

public void visit~name;format="capitalize"~Nodes(Consumer<Node> consumer) {
	graph.findNodes(~groupName~_~name~).
		forEachRemaining(consumer);
} 
>>

/** propertyName,STRINGPROPERTY;statementName,STRINGPROPERTY; **/
stringSetter(propertyName,statementName) ::= <<// ~propertyName~
public ~statementName~Node set~propertyName;format="capitalize"~(Node target) {
	if (node == null) return this;
	if (hasOutgoing(node, Parameters.~propertyName~_param))
		singleOutgoing(node, Parameters.~propertyName~_param).delete();
	node.createRelationshipTo(target, Parameters.~propertyName~_param);
   return this;
}

public Node get~propertyName;format="capitalize"~() {
	if (!hasOutgoing(node, Parameters.~propertyName~_param)) return null;
	final Relationship relationship = singleOutgoing(node, Parameters.~propertyName~_param);
	return other(node, relationship);
}

public void remove~propertyName;format="capitalize"~() {
	final Relationship outgoing = singleOutgoing(node, Parameters.~propertyName~_param);
	if (outgoing == null) return;
	final Node other = other(node, outgoing);
	outgoing.delete();
	tryToDeleteNode(other);
} 
>>
