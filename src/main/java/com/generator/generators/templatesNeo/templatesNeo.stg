/* uuid : 07ef5df3-c897-469a-b47c-0a2990655c7a */
delimiters "~", "~"

/** comments,LISTPROPERTY;name,STRINGPROPERTY;packageName,STRINGPROPERTY;statements,KEYVALUELISTPROPERTY,declaration,name,newInstance; **/
NeoGroupClassDeclaration(comments,name,packageName,statements) ::= <<~if(packageName)~package ~packageName~;

import org.neo4j.graphdb.*;

import java.util.UUID;
import java.util.function.Consumer;

import static com.generator.editors.domain.BaseDomainVisitor.*;
import static ~packageName~.~name~Neo.~name~Labels.*;

~endif~
/**
 * Wraps Neo4j methods based on '~name~.stg' file <br/>
 * ~comments:{it|~it~};separator="\n *"~
 * todo: refactor to static methods (no need for node-encapsulation, just let clients get the NeoNodes, but static treatment of each node as a specific type
 */
public final class ~name~Neo {

	private final GraphDatabaseService graph;

	public enum ~name~Labels implements Label {
		~name~,   	
		~statements:{it|~name~_~it.name~};separator=",\n"~, 
		StringNode
	}

   public ~name~Neo(final GraphDatabaseService graph) {
 		this.graph = graph;
	}

   ~statements:{it|~it.newInstance~};separator="\r\n\r\n"~

	~statements:{it|~it.declaration~};separator="\r\n\r\n"~

	public interface ~name~NeoAction {

		void doAction(Transaction tx) throws Throwable;

		void exception(Throwable throwable);
	}

	public void doInTransaction(~name~NeoAction committer) {
		try (Transaction tx = graph.beginTx()) {
			try {
				committer.doAction(tx);
				tx.success();
			} catch (Throwable throwable) {
				committer.exception(throwable);
				tx.failure();
			}
		}
	}

	~defaultNodeTypes()~
} 
>>

/**  **/
bugfix2() ::= <<} 
>>

/** groupName,STRINGPROPERTY;name,STRINGPROPERTY;properties,KEYVALUELISTPROPERTY,name,relationships,setter; **/
declaration(groupName,name,properties) ::= <<public static final class ~name~Node {

	// ~groupName~
   private final Node node;
	private final UUID uuid;

~if(properties)~	public enum Parameters implements RelationshipType {
		~properties:{it|~it.name~_param};separator=", "~
	}

	~properties:{it|~if(it.relationships)~
~it.relationships~~endif~}~

	private enum KeyValueLabels implements Label {
		~properties:{it|~if(it.relationships)~~it.name;format="capitalize"~, ~endif~}~
	}

~endif~
	private ~name~Node(final GraphDatabaseService graph) {
		this.node = graph.createNode(~groupName~_~name~);
		this.node.setProperty("_uuid", UUID.randomUUID().toString());
		this.uuid = UUID.fromString(getString(node, "_uuid"));
	}

	private ~name~Node(final Node node) {
		// assuming node has label ~groupName~_~name~
		this.node = node;
		this.uuid = UUID.fromString(getString(node, "_uuid"));
	}

	public void delete() throws IllegalStateException {
		if (node.hasRelationship(Direction.INCOMING))
			throw new IllegalStateException(toString() + " has " + node.getDegree(Direction.INCOMING) + " dependent incoming relations. Delete these first.");
		tryToDeleteNode(node);
	}	

	public Node node() {
		return node;
	}

	public UUID getUuid() {
		return uuid;
	}

	@Override
	public boolean equals(Object o) {
		if (this == o) return true;
		if (o == null || getClass() != o.getClass()) return false;
		~name~Node that = (~name~Node) o;
		return uuid.equals(that.uuid);
	}

	@Override
	public int hashCode() {
		return uuid.hashCode();
	}

	@Override
	public String toString() {
		return getClass().getName() + "  " + uuid;
	}

   ~properties:{it|~it.setter~};separator="\n\n"~

	public interface ~name~NodeVisitor<T> {

		T visit(~name~Node node);	

	}

	public <T> T visit(~name~NodeVisitor<T> visitor) {
		return visitor.visit(this);
	}
} 
>>

/**  **/
defaultNodeTypes() ::= <<public static boolean isStringNode(Node node) {
	return node != null && node.hasLabel(StringNode);
}

// convenience-method for instantiating a new StringNode, and setting the value
public Node newStringNode(String value) {
	if (value==null) throw new IllegalArgumentException("value for newStringNode cannot be null");
	
	final Node node = graph.createNode(StringNode);
	node.setProperty("_uuid", UUID.randomUUID().toString());
	return newStringNode(node).setValue(value).node();
}

public static StringNode newStringNode(Node node) {

	//if (node==null) throw new IllegalArgumentException("node for newStringNode cannot be null");
	if (node==null) return null;
	
	final UUID uuid = UUID.fromString(getString(node, "_uuid"));

	return new StringNode() {
		@Override
		public StringNode setValue(String value) {
			node.setProperty("value", value);
			return this;
		}

		@Override
		public String getValue() {
			return getString(node, "value");
		}

		@Override
		public Node node() {
			return node;
		}

		@Override
		public UUID getUuid() {
			return uuid;
		}

		@Override
		public boolean equals(Object o) {
			if (this == o) return true;
			if (o == null || getClass() != o.getClass()) return false;
			StringNode that = (StringNode) o;
			return uuid.equals(that.getUuid());
		}

		@Override
		public int hashCode() {
			return uuid.hashCode();
		}

		@Override
		public String toString() {
			return getValue();
		}	
	};
}

public interface StringNode {

	public StringNode setValue(String value);

	public String getValue();

	public Node node();

	public UUID getUuid();
} 
>>

/** name,STRINGPROPERTY; **/
keyValueListInterfaceDecl(name) ::= <<void visit~name;format="capitalize"~(~name;format="capitalize"~KeyValue node); 
>>

/** kvNames,LISTPROPERTY;propertyName,STRINGPROPERTY;statementName,STRINGPROPERTY; **/
keyValueListSetter(kvNames,propertyName,statementName) ::= <<public interface ~propertyName;format="capitalize"~KeyValue {

	~kvNames:{it|public Node get~it;format="capitalize"~Value();};separator="\n\n"~

	~kvNames:{it|public ~propertyName;format="capitalize"~KeyValue set~it;format="capitalize"~Value(Node value);};separator="\n\n"~

	public Node node();

	public UUID getUuid();
}

public ~statementName~Node add~propertyName;format="capitalize"~Value(~propertyName;format="capitalize"~KeyValue value) {
	this.node.createRelationshipTo(value.node(), Parameters.~propertyName~_param);
   return this;
}

public ~propertyName;format="capitalize"~KeyValue new~propertyName;format="capitalize"~KeyValue(GraphDatabaseService graph) {
	final Node node = graph.createNode(KeyValueLabels.~propertyName;format="capitalize"~);
	node.setProperty("_uuid", UUID.randomUUID().toString());
	return new~propertyName;format="capitalize"~KeyValue(node);
}

public static ~propertyName;format="capitalize"~KeyValue new~propertyName;format="capitalize"~KeyValue(Node node) {
	if (node==null) throw new IllegalArgumentException("node for new~propertyName;format="capitalize"~KeyValue cannot be null");
	
	final UUID uuid = UUID.fromString(getString(node, "_uuid"));

	return new ~propertyName;format="capitalize"~KeyValue() {
		
		~kvNames:{it|@Override
public Node get~it;format="capitalize"~Value() {
	if (!hasOutgoing(node, ~propertyName;format="capitalize"~Relationships.~it~)) return null;
	return other(node, singleOutgoing(node, ~propertyName;format="capitalize"~Relationships.~it~));
~bugfix2()~

@Override
public ~propertyName;format="capitalize"~KeyValue set~it;format="capitalize"~Value(Node value) {
	if (hasOutgoing(node, ~propertyName;format="capitalize"~Relationships.~it~)) {
		final Relationship outgoing = singleOutgoing(node, ~propertyName;format="capitalize"~Relationships.~it~);
		final Node other = other(node, outgoing);
		outgoing.delete();
		tryToDeleteNode(other);
	~bugfix2()~

	if (value != null)
		node.createRelationshipTo(value, ~propertyName;format="capitalize"~Relationships.~it~);

	return this;
~bugfix2()~
 		};separator="\n"~
		@Override
		public Node node() {
			return node;
		}

		@Override
		public UUID getUuid() {
			return uuid;
		}

		@Override
		public boolean equals(Object o) {
			if (this == o) return true;
			if (o == null || getClass() != o.getClass()) return false;
			StringNode that = (StringNode) o;
			return uuid.equals(that.getUuid());
		}

		@Override
		public int hashCode() {
			return uuid.hashCode();
		}
	};
}

public void forEach~propertyName;format="capitalize"~Value(Consumer<~propertyName;format="capitalize"~KeyValue> consumer) {
	for (Relationship relationship : node.getRelationships(Direction.OUTGOING, Parameters.~propertyName~_param)) {
		consumer.accept(new~propertyName;format="capitalize"~KeyValue(other(node, relationship)));
	}
} 
>>

/** name,STRINGPROPERTY;types,LISTPROPERTY; **/
keyValueRelationships(name,types) ::= <<private enum ~name;format="capitalize"~Relationships implements RelationshipType {
	~types:{it|~it~};separator=", "~
} 
>>

/** name,STRINGPROPERTY; **/
keyValueVisitor(name) ::= <<for (Relationship relationship : node.getRelationships(Direction.OUTGOING, Parameters.~name~_param)) 
	visitor.visit~name;format="capitalize"~(new~name;format="capitalize"~KeyValue(other(node, relationship))); 
>>

/** name,STRINGPROPERTY; **/
listInterfaceDecl(name) ::= <<void visit~name;format="capitalize"~(Node node); 
>>

/** propertyName,STRINGPROPERTY;statementName,STRINGPROPERTY; **/
listSetter(propertyName,statementName) ::= <<// ~propertyName~
public ~statementName~Node add~propertyName;format="capitalize"~Value(Node target) {
	if (node == null) return this;
	if (isAlreadyRelated(node, target, Parameters.~propertyName~_param)) return this;
	node.createRelationshipTo(target, Parameters.~propertyName~_param);
   return this;
}

public void forEach~propertyName;format="capitalize"~(Consumer<Node> consumer) {
	for (Relationship relationship : node.getRelationships(Direction.OUTGOING, Parameters.~propertyName~_param))
		consumer.accept(other(node, relationship));
}

public void forEach~propertyName;format="capitalize"~Relation(Consumer<Relationship> consumer) {
	for (Relationship relationship : node.getRelationships(Direction.OUTGOING, Parameters.~propertyName~_param))
		consumer.accept(relationship);
} 
>>

/** name,STRINGPROPERTY; **/
listVisitor(name) ::= <<for (Relationship relationship : node.getRelationships(Direction.OUTGOING, Parameters.~name~_param)) 
	visitor.visit~name;format="capitalize"~(other(node, relationship)); 
>>

/** groupName,STRINGPROPERTY;name,STRINGPROPERTY; **/
newInstance(groupName,name) ::= <<public static boolean is~name;format="capitalize"~(Node node) {
	return node != null && node.hasLabel(~groupName~_~name~);
}

public static ~name~Node new~name;format="capitalize"~(Node node) {
	return new ~name~Node(node);
}

public ~name~Node new~name;format="capitalize"~() {
	return new ~name~Node(graph);
}

public ResourceIterator<~name~Node> findAll~name;format="capitalize"~() { 
	return graph.findNodes(~groupName~_~name~).map(~groupName~Neo::new~name;format="capitalize"~);
} 
>>

/** name,STRINGPROPERTY; **/
stringInterfaceDecl(name) ::= <<void visit~name;format="capitalize"~(Node node); 
>>

/** propertyName,STRINGPROPERTY;statementName,STRINGPROPERTY; **/
stringSetter(propertyName,statementName) ::= <<// ~propertyName~
public ~statementName~Node set~propertyName;format="capitalize"~(Node target) {
	if (node == null) return this;
	if (hasOutgoing(node, Parameters.~propertyName~_param))
		singleOutgoing(node, Parameters.~propertyName~_param).delete();
	node.createRelationshipTo(target, Parameters.~propertyName~_param);
   return this;
}

public Node get~propertyName;format="capitalize"~() {
	if (!hasOutgoing(node, Parameters.~propertyName~_param)) return null;
	final Relationship relationship = singleOutgoing(node, Parameters.~propertyName~_param);
	return other(node, relationship);
}

public Relationship get~propertyName;format="capitalize"~Relation() {
	if (!hasOutgoing(node, Parameters.~propertyName~_param)) return null;
	return singleOutgoing(node, Parameters.~propertyName~_param);
}

public void remove~propertyName;format="capitalize"~() {
	final Relationship outgoing = singleOutgoing(node, Parameters.~propertyName~_param);
	if (outgoing == null) return;
	final Node other = other(node, outgoing);
	outgoing.delete();
	tryToDeleteNode(other);
} 
>>

/** name,STRINGPROPERTY; **/
stringVisitor(name) ::= <<if (hasOutgoing(node, Parameters.~name~_param))
	visitor.visit~name;format="capitalize"~(other(node, singleOutgoing(node, Parameters.~name~_param))); 
>>
