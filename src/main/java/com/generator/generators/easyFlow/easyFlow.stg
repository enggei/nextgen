/* uuid : 5a2715ab-2732-47c7-a63b-c5991582be41 */
delimiters "~", "~"

/** name,StringProperty;state,StringProperty; **/
declaration(name,state) ::= <<
.whenEnter(~state~, new ContextHandler<~name~Context>() {
    @Override
    public void call(final ~name~Context context) throws Exception {
        //log.debug("~state;format="humpToCap"~");
        if (listener != null) listener.onEnter("~state~", context);
        ~state;format="toLower"~(context);
    }
})
>>

/** bindings,KeyValueListProperty,declaration,impl;context,StringProperty;events,StringProperty;extends,StringProperty;name,StringProperty;package,StringProperty;states,StringProperty;superParams,KeyValueListProperty,name,type;transit,StringProperty; **/
easyFlow(bindings,context,events,extends,name,package,states,superParams,transit) ::= <<
package ~package~;

import au.com.ds.ef.*;
import au.com.ds.ef.call.ContextHandler;
import au.com.ds.ef.call.ExecutionErrorHandler;
import au.com.ds.ef.err.ExecutionError;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import static au.com.ds.ef.FlowBuilder.*;
import static ~package~.~name~.States.*;
import static ~package~.~name~.Events.*;

/**
 * http://datasymphony.com.au/open-source/easyflow/
 */
public abstract class ~name~ ~if(extends)~extends ~extends~ ~endif~{

    protected static final Logger log = LoggerFactory.getLogger(~name~.class);

    ~context~

    ~states~

    ~events~

    /** ~name~Listener  **/
    public interface ~name~Listener {
        void onEnter(String state, ~name~Context context);
        void onError(ExecutionError error, StatefulContext context);
    }

    private final EasyFlow<~name~Context> fsm;
    protected ~name~Listener listener;

    public ~name~(~superParams:{it|~it.type~ ~it.name~};separator=", "~) {
        super(~superParams:{it|~it.name~};separator=", "~);

        // states and transitions:
        this.fsm = ~transit~;

        // binding:
        this.fsm
            .executor(new SyncExecutor())
            ~bindings:{it|~it.declaration~};separator="\n"~.
            whenError(new ExecutionErrorHandler<StatefulContext>() {
                @Override
                public void call(ExecutionError error, StatefulContext context) {
                    log.info("ERROR");
                    if (listener != null) listener.onError(error, context);
                    onERROR(error, (~name~Context) context);
                    }
                });
    }

    public void start(final ~name~Context context) {
        this.fsm.start(context);
    }

    public void start(final ~name~Context context, ~name~Listener listener) {
        this.listener = listener;
        this.fsm.start(context);
    }

    ~bindings:{it|~it.impl~};separator="\n"~

    protected abstract void onERROR(final ExecutionError error, final ~name~Context context);
}
>>

/** events,ListProperty; **/
events(events) ::= <<
enum Events implements EventEnum {
    ~events:{it|~it~};separator=",\n"~
}
>>

/** name,StringProperty;state,StringProperty; **/
impl(name,state) ::= <<
protected abstract void ~state;format="toLower"~(final ~name~Context context) throws Exception;
>>

/**  **/
mvn() ::= <<
<dependency>
    <groupId>au.com.datasymphony</groupId>
    <artifactId>EasyFlow</artifactId>
    <version>1.3</version>
<!-- test xx-->
</dependency>
>>

/** comment,StringProperty;name,StringProperty; **/
stateDeclaration(comment,name) ::= <<
~name~~if(comment)~ /* ~comment~ */ ~endif~
>>

/** contextGeneric,StringProperty;name,StringProperty;properties,KeyValueListProperty,comment,modifier,name,type,value; **/
statefulContext(contextGeneric,name,properties) ::= <<
static class ~name~~if(contextGeneric)~~contextGeneric~~endif~Context extends StatefulContext {
    ~properties:{it|~if(it.modifier)~~it.modifier~ ~endif~~it.type~ ~it.name~~if(it.value)~ = ~it.value~~endif~;~if(it.comment)~ //~it.comment~~endif~};separator="\n"~
}
>>

/** states,ListProperty; **/
states(states) ::= <<
enum States implements StateEnum {
    ~states:{it|~it~};separator=",\n"~
}
>>

/** event,StringProperty;isFinish,StringProperty;isInit,StringProperty;state,StringProperty;transits,ListProperty; **/
transit(event,isFinish,isInit,state,transits) ::= <<
 ~if(isInit)~from(~state~)~else~on(~event~).~if(isFinish)~finish~else~to~endif~(~state~)~endif~~if(transits)~.transit(
~transits:{it|~it~};separator=",\n"~
)~endif~
>>
