/* uuid : 245d5245-c5cd-4d08-81ea-b53af616a656 */
delimiters "~", "~"

/** name,STRINGPROPERTY;state,STRINGPROPERTY; **/
declaration(name,state) ::= <<.whenEnter(~state~, new ContextHandler<~name~Context>() {
    @Override
    public void call(final ~name~Context context) throws Exception {
        //log.debug("~state;format="humpToCap"~");
        if (listener != null) listener.onEnter("~state~", context);
        ~state;format="toLower"~(context);
    }
}) 
>>

/** bindings,KEYVALUELISTPROPERTY,declaration,impl;context,STRINGPROPERTY;events,STRINGPROPERTY;extends,STRINGPROPERTY;name,STRINGPROPERTY;package,STRINGPROPERTY;states,STRINGPROPERTY;superParams,KEYVALUELISTPROPERTY,name,type;transit,STRINGPROPERTY; **/
easyFlow(bindings,context,events,extends,name,package,states,superParams,transit) ::= <<~if(package)~package ~package~;

~endif~import au.com.ds.ef.*;
import au.com.ds.ef.call.ContextHandler;
import au.com.ds.ef.call.ExecutionErrorHandler;
import au.com.ds.ef.err.ExecutionError;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import static au.com.ds.ef.FlowBuilder.*;
import static ~package~.~name~.States.*;
import static ~package~.~name~.Events.*;

/**
 * http://datasymphony.com.au/open-source/easyflow/
 */
public abstract class ~name~ ~if(extends)~extends ~extends~ ~endif~{

    protected static final Logger log = LoggerFactory.getLogger(~name~.class);

    ~context~

    ~states~

    ~events~

    /** ~name~Listener  **/
    public interface ~name~Listener {
        void onEnter(String state, ~name~Context context);
        void onError(ExecutionError error, StatefulContext context);
    }

    private final EasyFlow<~name~Context> fsm;
    protected ~name~Listener listener;

    public ~name~(~superParams:{it|~it.type~ ~it.name~};separator=", "~) {
        super(~superParams:{it|~it.name~};separator=", "~);

        // states and transitions:
        this.fsm = ~transit~;

        // binding:
        this.fsm
            .executor(new SyncExecutor())
            ~bindings:{it|~it.declaration~};separator="\n"~.
            whenError(new ExecutionErrorHandler<StatefulContext>() {
                @Override
                public void call(ExecutionError error, StatefulContext context) {
                    log.info("ERROR");
                    if (listener != null) listener.onError(error, context);
                    onERROR(error,context);
                    }
                });
    }

    public void start(final ~name~Context context) {
        this.fsm.start(context);
    }

    public void start(final ~name~Context context, ~name~Listener listener) {
        this.listener = listener;
        this.fsm.start(context);
    }

    ~bindings:{it|~it.impl~};separator="\n"~

    protected abstract void onERROR(final ExecutionError error, final StatefulContext context);
} 
>>

/** events,LISTPROPERTY; **/
events(events) ::= <<enum Events implements EventEnum {
    ~events:{it|~it~};separator=",\n"~
}
>>

/** name,STRINGPROPERTY;state,STRINGPROPERTY; **/
impl(name,state) ::= <<protected abstract void ~state;format="toLower"~(final ~name~Context context) throws Exception;
>>

/**  **/
mvn() ::= <<<dependency>
    <groupId>au.com.datasymphony</groupId>
    <artifactId>EasyFlow</artifactId>
    <version>1.3</version>
</dependency>
>>

/** comment,STRINGPROPERTY;name,STRINGPROPERTY; **/
stateDeclaration(comment,name) ::= <<~name~~if(comment)~ /* ~comment~ */ ~endif~
>>

/** contextGeneric,STRINGPROPERTY;name,STRINGPROPERTY;properties,KEYVALUELISTPROPERTY,comment,modifier,name,type,value; **/
statefulContext(contextGeneric,name,properties) ::= <<static class ~name~~if(contextGeneric)~~contextGeneric~~endif~Context extends StatefulContext {
    ~properties:{it|~if(it.modifier)~~it.modifier~ ~endif~~it.type~ ~it.name~~if(it.value)~ = ~it.value~~endif~;~if(it.comment)~ //~it.comment~~endif~};separator="\n"~
}
>>

/** states,LISTPROPERTY; **/
states(states) ::= <<enum States implements StateEnum {
    ~states:{it|~it~};separator=",\n"~
}
>>

/** event,STRINGPROPERTY;isFinish,STRINGPROPERTY;isInit,STRINGPROPERTY;state,STRINGPROPERTY;transits,LISTPROPERTY; **/
transit(event,isFinish,isInit,state,transits) ::= << ~if(isInit)~from(~state~)~else~on(~event~).~if(isFinish)~finish~else~to~endif~(~state~)~endif~~if(transits)~.transit(
~transits:{it|~it~};separator=",\n"~
)~endif~ 
>>
