/* Utils 7c3a6795-124b-4dac-b45d-6a8747191539*/
delimiters "~", "~"

VertxUtil(package,name) ::= <<package ~package~;

import com.codahale.metrics.MetricRegistry;
import com.codahale.metrics.Timer;
import io.vertx.core.AsyncResult;
import io.vertx.core.DeploymentOptions;
import io.vertx.core.Handler;
import io.vertx.core.Vertx;
import io.vertx.core.eventbus.DeliveryOptions;
import io.vertx.core.eventbus.Message;
import io.vertx.core.http.HttpServerRequest;
import io.vertx.core.json.JsonObject;
import io.vertx.core.shareddata.LocalMap;
import io.vertx.core.shareddata.SharedData;
import org.slf4j.Logger;

import java.util.concurrent.atomic.AtomicLong;


/**
 * NextGen core Vertx utils 10.01.17
 *
 * Vert.x: http://vertx.io/docs/
 */
public class ~name~ {

	private static final int KB = 1024;
	private static final int MB = 1024 * KB;

	private static final MetricRegistry metricRegistry = new MetricRegistry();

	private static final AtomicLong NO_VERTICLES = new AtomicLong();

	public static long MB(int size) {
		return (long) (size * MB);
	}

	public static String getBody(AsyncResult<Message<JsonObject~Bugfix()~> result) {
		final Message<JsonObject> message = result.result();
		return (message != null ? (message.body() != null ? message.body().encode() : message.toString()) : "UNKNOWN ERROR");
	}

	public static void putInLocalMap(Vertx vertx, Logger log, String mapName, String key, Object value) {

		final SharedData sharedData = vertx.sharedData();
		final LocalMap<Object, Object> localMap = sharedData.getLocalMap(mapName);
		log.info("putting '" + key + "' = '" + value + "' in local map '" + mapName + "'");
		localMap.put(key, value);
	}

	@SuppressWarnings("unchecked")
	public static <V> V removeFromLocalMap(Vertx vertx, Logger log, String mapName, String key) {
		final SharedData sharedData = vertx.sharedData();
		final LocalMap<Object, Object> localMap = sharedData.getLocalMap(mapName);
		log.info("removing '" + key + "' = '" + (localMap.get(key)) + "' in local map '" + mapName + "'");
		return (V) localMap.remove(key);
	}

	@SuppressWarnings("unchecked")
	public static <V> V getFromLocalMap(Vertx vertx, Logger log, String mapName, String key) {
		final SharedData sharedData = vertx.sharedData();
		final LocalMap<Object, Object> localMap = sharedData.getLocalMap(mapName);
		log.info("getting '" + key + "' = '" + (localMap.get(key)) + "' from local map '" + mapName + "'");
		return (V) localMap.get(key);
	}

	public static void putInClusterMap(Vertx vertx, Logger log, String mapName, String key, Object value, SuccessHandler<Void> successHandler) {

		vertx.sharedData().getClusterWideMap(mapName, result -> {

			if (result.failed()) {

				log.error("could not get clusterWiteMap '" + mapName + "'");

				successHandler.onFail(new AsyncResult<Void>() {
					@Override
					public Void result() {
						return null;
					}

					@Override
					public Throwable cause() {
						return result.cause();
					}

					@Override
					public boolean succeeded() {
						return result.succeeded();
					}

					@Override
					public boolean failed() {
						return result.failed();
					}
				});
				return;
			}

			result.result().put(key, value, resultPut -> {

				if (resultPut.failed()) {
					log.error("could not store " + key + " (" + value + ") in " + mapName);
					successHandler.onFail(resultPut);
					return;
				}

				log.info(key + " stored in sessions");
				successHandler.onSuccess(resultPut);
			});
		});
	}

	@SuppressWarnings("unchecked")
	public static <V> void removeFromClusterMap(Vertx vertx, Logger log, String mapName, String key, SuccessHandler<V> successHandler) {

		vertx.sharedData().getClusterWideMap(mapName, result -> {

			if (result.failed()) {

				log.error("could not get clusterWideMap '" + mapName + "'");

				successHandler.onFail(new AsyncResult<V>() {
					@Override
					public V result() {
						return null;
					}

					@Override
					public Throwable cause() {
						return result.cause();
					}

					@Override
					public boolean succeeded() {
						return result.succeeded();
					}

					@Override
					public boolean failed() {
						return result.failed();
					}
				});
				return;
			}

			result.result().remove(key, resultGet -> {

				if (resultGet.failed()) {
					log.error("could not remove '" + key + "' from '" + mapName + "'");
					successHandler.onFail((AsyncResult<V>) resultGet);
					return;
				}

				log.info("'" + key + "' removed from '" + mapName + "'");
				successHandler.onSuccess((AsyncResult<V>) resultGet);
			});
		});
	}

	@SuppressWarnings("unchecked")
	public static <V> void getFromClusterMap(Vertx vertx, Logger log, String mapName, String key, SuccessHandler<V> successHandler) {

		vertx.sharedData().getClusterWideMap(mapName, result -> {

			if (result.failed()) {

				log.error("could not get clusterWideMap '" + mapName + "'");

				successHandler.onFail(new AsyncResult<V>() {
					@Override
					public V result() {
						return null;
					}

					@Override
					public Throwable cause() {
						return result.cause();
					}

					@Override
					public boolean succeeded() {
						return result.succeeded();
					}

					@Override
					public boolean failed() {
						return result.failed();
					}
				});
				return;
			}

			result.result().get(key, resultGet -> {

				if (resultGet.failed()) {
					log.error("could not get '" + key + "' from '" + mapName + "'");
					successHandler.onFail((AsyncResult<V>) resultGet);
					return;
				}

				if (resultGet.result() == null) {
					log.error("could not get '" + key + "' from '" + mapName + "', its null.");
					successHandler.onFail(new AsyncResult<V>() {
						@Override
						public V result() {
							return null;
						}

						@Override
						public Throwable cause() {
							return new Throwable("'" + key + "'" + " has null-value in '" + mapName + "'");
						}

						@Override
						public boolean succeeded() {
							return false;
						}

						@Override
						public boolean failed() {
							return true;
						}
					});
					return;
				}

				log.info("'" + key + "' found in '" + mapName + "'");
				successHandler.onSuccess((AsyncResult<V>) resultGet);
			});
		});
	}


	public interface SuccessHandler<T> {

		void onSuccess(AsyncResult<T> result);

		void onFail(AsyncResult<T> result);

	}

	public interface Executor<R, T> extends SuccessHandler<T> {

		R execute();
	}

	@SuppressWarnings("unchecked")
	public static <R> void executeBlocking(Vertx vertx, Logger log, Executor<R, R> executor) {

		// todo check if using metricRegistry like this is the best
		final Timer timer = metricRegistry.timer("Blocking timer");
		final Timer.Context time = timer.time();

		vertx.executeBlocking(future -> {

			final R result = executor.execute();

			if (result == null) future.complete();
			else future.complete(result);

		}, res -> {

			time.stop();

			if (res.failed()) {
				executor.onFail((AsyncResult<R>) res);
				return;
			}

			executor.onSuccess((AsyncResult<R>) res);
		});
	}

	public static <T> void consume(Vertx vertx, String deploymentId, String address, Logger log, Handler<Message<T~Bugfix()~> messageHandler) {
		log.info(deploymentId + " listening for '" + address + "' messages");
		vertx.eventBus().consumer(address, messageHandler);
	}

	public static <T> void sendMessage(Vertx vertx, String address, JsonObject content, Logger log, SuccessHandler<Message<T~Bugfix()~> handler) {
		sendMessage(vertx, address, content, null, log, handler);
	}

	public static <T> void sendMessage(Vertx vertx, String address, JsonObject content, DeliveryOptions options, Logger log, SuccessHandler<Message<T~Bugfix()~> handler) {

		if (options == null) options = new DeliveryOptions();

		vertx.eventBus().<T>send(address, content, options, result -> {

			if (result.failed()) {
				log.error("error sending message '" + content.encode() + "' to '" + address + "' : " + result.cause(), result.cause());
				handler.onFail(result);
				return;
			}

			log.debug(content.encode() + " sent to " + address + " " + result.result().body());
			handler.onSuccess(result);
		});
	}

	public static void undeploy(Vertx vertx, Logger log, String deploymentId, SuccessHandler<Void> handler) {

		vertx.undeploy(deploymentId, result -> {

			if (result.failed()) {
				handler.onFail(result);
				log.error("could not UNDEPLOY '" + deploymentId + "'", result.cause());
				return;
			}

			log.info("Undeployed " + deploymentId + " (" + NO_VERTICLES.decrementAndGet() + ")");
			handler.onSuccess(result);
		});
	}

	public static void deploy(Vertx vertx, Class verticleClass, DeploymentOptions deploymentOptions, Logger log, SuccessHandler<String> handler) {
		deploy(vertx, verticleClass.getCanonicalName(), deploymentOptions, log, handler);
	}

	public static void deploy(Vertx vertx, String className, DeploymentOptions deploymentOptions, Logger log, SuccessHandler<String> handler) {

		if (deploymentOptions == null) deploymentOptions = new DeploymentOptions();

		vertx.deployVerticle(className, deploymentOptions, result -> {

			if (result.failed()) {
				handler.onFail(result);
				log.error("could not DEPLOY VERTICLE '" + className + "'", result.cause());
				return;
			}

			log.info(className + " deployed (" + NO_VERTICLES.incrementAndGet() + ")");
			handler.onSuccess(result);
		});
	}

	public static void deploy(Vertx vertx, Class verticleClass, Logger log, SuccessHandler<String> handler) {
		deploy(vertx, verticleClass.getCanonicalName(), log, handler);
	}

	public static void deploy(Vertx vertx, Class verticleClass, JsonObject config, Logger log, SuccessHandler<String> handler) {
		deploy(vertx, verticleClass.getCanonicalName(), config, log, handler);
	}

	public static void deploy(Vertx vertx, String verticleClass, Logger log, SuccessHandler<String> handler) {
		deploy(vertx, verticleClass, new DeploymentOptions(), log, handler);
	}

	public static void deploy(Vertx vertx, String verticleClass, JsonObject config, Logger log, SuccessHandler<String> handler) {

		final DeploymentOptions deploymentOptions = new DeploymentOptions();
		if (config != null) deploymentOptions.setConfig(config);

		deploy(vertx, verticleClass, deploymentOptions, log, handler);
	}

	/**
	 * Resolves HTTP request remote IP.
	 *
	 * @param request HTTP request
	 * @return IP address
	 */
	public static String getRemoteIP(HttpServerRequest request) {
		if (request.headers().contains("X-Forwarded-For"))
			return request.headers().get("X-Forwarded-For");

		return request.remoteAddress().host();
	}
}>>

Bugfix() ::= <<> >>

ChronicleUtil(package,name) ::= <<package ~package~;

import net.openhft.chronicle.queue.ExcerptTailer;
import net.openhft.chronicle.queue.RollCycle;
import net.openhft.chronicle.queue.TailerDirection;
import net.openhft.chronicle.queue.impl.RollingChronicleQueue;
import net.openhft.chronicle.wire.DocumentContext;
import net.openhft.chronicle.wire.WireIn;
import net.openhft.chronicle.wire.WireOut;

import java.text.ParseException;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;
import java.util.stream.Collectors;

/**
 * NextGen core Chronicle utils 19.01.17
 * 
 * Chronicle: http://chronicle.software/products/chronicle-queue/
 */
public class ~name~ {

	private final static org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(~name~.class);

	/**
	 * Interface defining how to read and write a record in the Chronicle queue.
	 */
	public interface ChronicleRecord<R> {
		long id(WireIn wireIn);
		void read(WireIn wireIn, R recordOut);
		void write(final R recordIn, WireOut wireOut);
	}

	private static final class Tuple<F, S> {

		private F first;
		private S second;

		public Tuple(F first, S second) {
			this.first = first;
			this.second = second;
		}

		public F getFirst() {
			return first;
		}

		public S getSecond() {
			return second;
		}

		public void setFirst(F first) {
			this.first = first;
		}

		public void setSecond(S second) {
			this.second = second;
		}

		@Override
		public String toString() {
			return "[" + first + "," + second + "]";
		}
	}

	private static final class ChronicleMetaData {

		private final RollCycle rollCycle;
		private final List<Tuple<Integer, Long>~Bugfix()~ cycleRanges;	// List of <chronicle cycle, chronicle sequence length>
		private long size = 0;

		ChronicleMetaData(final RollingChronicleQueue queue) {
			if (queue == null)
				throw new IllegalArgumentException("queue cannot be null!");

			rollCycle = queue.rollCycle();
			cycleRanges = new ArrayList<>();

			try {
				cycleRanges.addAll(
					getQueueCycles(queue)
						.stream()
						.map(c -> new Tuple<>(c, 0l))
						.collect(Collectors.toList())
				);
			}
			catch (Throwable e) {
				e.printStackTrace();
				throw new RuntimeException("Unable to collect queue cycles", e);
			}

			if (cycleRanges.isEmpty())
				throw new RuntimeException("cycleRanges is empty");

			ExcerptTailer tailer = queue.createTailer();

			final long currentIndex = tailer.index();
			int currentCycle = tailer.cycle();
			long currentSeqNum = rollCycle.toSequenceNumber(currentIndex);

			// Collect highest sequence number per cycle
			// TODO: For large chronicles, find highest sequence number by binary searching for record presence
			try (DocumentContext dc = tailer.readingDocument()) {
				if (dc.isPresent()) {
					// Scan and count all records
					int crIndex = 0;
					do {
						while (tailer.moveToIndex(rollCycle.toIndex(currentCycle, currentSeqNum++))) {
							//log.debug("Found record at: " + tailer.cycle() + ":" + rollCycle.toSequenceNumber(tailer.index()));
						}

						cycleRanges.get(crIndex).setSecond(currentSeqNum - 1);
						size += cycleRanges.get(crIndex).getSecond();

						if (crIndex < cycleRanges.size() - 1) {
							currentSeqNum = 0;
							currentCycle = cycleRanges.get(++crIndex).getFirst();
							log.debug("Changed cycle to: " + currentCycle);
						}
					} while(currentCycle != tailer.cycle());
				}
				else {
					log.debug("No records present!");
				}
			}
		}

		public List<Tuple<Integer, Long>~Bugfix()~ cycleRanges() {
			return cycleRanges;
		}

		public RollCycle rollCycle() {
			return rollCycle;
		}

		public long size() {
			return size;
		}

		public long lastIndex() {
			Tuple<Integer, Long> cycleRange = cycleRanges.get(cycleRanges.size() - 1);

			long maxSeqNum = cycleRange.getSecond();

			if (maxSeqNum > 0)
				maxSeqNum -= 1l;

			return rollCycle.toIndex(cycleRange.getFirst(), maxSeqNum);
		}
	}

	/**
	 * Sequential Chronicle Excerpt record search.
	 * O(N)
	 *
	 * @param queue  Chronicle queue
	 * @param t      Search value (e.g. a timestamp or other sequential record id field)
	 * @param record Function that extracts record id field
	 * @return
	 */
	public static long sequentialExcerptSearch(final RollingChronicleQueue queue, final long t, ChronicleRecord record) {
		return sequentialExcerptSearch(queue, t, queue.firstIndex(), new ChronicleMetaData(queue), record);
	}

	/**
	 * Sequential Chronicle Excerpt record search.
	 * O(N)
	 *
	 * @param queue  Chronicle queue
	 * @param t      Search value (e.g. a timestamp or other sequential record id field)
	 * @param record Function that extracts record id field
	 * @return
	 */
	public static long sequentialExcerptSearchReverse(final RollingChronicleQueue queue, final long t, ChronicleRecord record) {
		final ChronicleMetaData metaData = new ChronicleMetaData(queue);
		return sequentialExcerptSearch(queue, t, metaData.lastIndex(), metaData, record);
	}

	/**
	 * Sequential Chronicle Excerpt record search.
	 * O(N)
	 *
	 * @param queue	 Chronicle queue
	 * @param t			 Search value (e.g. a timestamp or other sequential record id field)
	 * @param start    Starting index
	 * @param metaData Meta data
	 * @param record   Function that extracts record id field
	 * @return			 Chronicle queue index, or 0 if not found
	 */
	static long sequentialExcerptSearch(final RollingChronicleQueue queue, final long t, final long start, final ChronicleMetaData metaData, ChronicleRecord record) {

		log.debug("Searching for: " + t);

		long result = sequentialExcerptSearch(queue.createTailer(), t, start, metaData, record);

		if (result < 0) {
			log.debug("Not found: " + t);
			return 0;
		}

		return result;
	}

	/**
	 * Binary Chronicle Excerpt record search.
	 * O(log N)
	 * 
	 * @param queue	Chronicle queue
	 * @param t			Search value (e.g. a timestamp or other sequential record id field)
	 * @return			Chronicle queue index, or 0 if not found
	 */
	public static long binaryExcerptSearch(final RollingChronicleQueue queue, final long t, ChronicleRecord record) {

		ChronicleMetaData metaData = new ChronicleMetaData(queue);

		log.debug("Searching for: " + t);

		long result = binaryExcerptSearch(queue.createTailer(), t, metaData.size() / 2, metaData.size() / 4, metaData, record);

		if (result < 0) {
			log.debug("Not found: " + t);
			return 0;
		}

		return result;
	}

	/**
	 * Helper method.
	 * Sequential Chronicle Excerpt record search.
	 * O(N)
	 *
	 * @param tailer      Chronicle Excerpt tailer
	 * @param t           Search value (e.g. a timestamp or other sequential record id field)
	 * @param start       Starting index
	 * @param metaData    Metadata
	 * @param record      Function that extracts record id field
	 * @return            Chronicle queue index, or -1 if an error occurred
	 * @throws IndexOutOfBoundsException
	 */
	static long sequentialExcerptSearch(final ExcerptTailer tailer, final long t, final long start, final ChronicleMetaData metaData, ChronicleRecord record) throws IndexOutOfBoundsException {

		final RollCycle rollCycle = metaData.rollCycle();
		final List<Tuple<Integer, Long>~Bugfix()~ cycleRanges = metaData.cycleRanges();

		final long lastIndex = rollCycle.toIndex(cycleRanges.get(cycleRanges.size() - 1).getFirst(), cycleRanges.get(cycleRanges.size() - 1).getSecond());

		if (start >= lastIndex || start < tailer.queue().firstIndex()) {
			throw new IndexOutOfBoundsException("start out of bounds: " + start + " >= " + lastIndex + " || " + start + " < " + tailer.queue().firstIndex());
		}

		if (!tailer.moveToIndex(start)) {
			log.error("No excerpt at " + start);
			return -1l;
		}

		long index = start;
		long seqNum = rollCycle.toSequenceNumber(index);
		final AtomicInteger cycle = new AtomicInteger(rollCycle.toCycle(index));

		final AtomicInteger cycleIndex = new AtomicInteger(0);

		// Which cycle index are we on?
		Tuple<Integer, Long> cycleRange = cycleRanges.stream().filter(cr -> {
			if (cr.getFirst() == cycle.get())
				return true;

			cycleIndex.incrementAndGet();

			return false;
		}).findFirst().get();

		assert(cycleRange.equals(cycleRanges.get(cycleIndex.get())));
		assert(cycle.get() == cycleRanges.get(cycleIndex.get()).getFirst());

		final AtomicLong id = new AtomicLong(0);
		tailer.readDocument(wireIn -> id.set(record.id(wireIn)));

		final boolean goDown = t < id.get();
		log.debug("Scanning " + (goDown ? "DOWN" : "UP"));
		log.debug("Current position: (cycle: " + cycle.get() + ", seqNum: " + seqNum + ", length: " + cycleRange.getSecond() + ")");

		while (goDown ? (t < id.get()) : (t > id.get())) {
			// Go to next cycle when needed
			if (goDown && seqNum == 0) {
				if (cycleIndex.get() == 0) return index; // We're at the very beginning
				cycleRange = cycleRanges.get(cycleIndex.decrementAndGet());
				cycle.set(cycleRange.getFirst());
				seqNum = cycleRange.getSecond() - 1;
			}
			else if (!goDown && seqNum == (cycleRange.getSecond() - 1)) {
				if (cycleIndex.get() == (cycleRanges.size() - 1)) return index; // We're at the very end
				cycleRange = cycleRanges.get(cycleIndex.incrementAndGet());
				cycle.set(cycleRange.getFirst());
				seqNum = 0;
			}
			else seqNum += goDown ? -1l : 1l;

			log.debug("Next position: (cycle: " + cycle.get() + ", seqNum: " + seqNum + ", length: " + cycleRange.getSecond() + ")");

			index = rollCycle.toIndex(cycle.get(), seqNum);
			if (!tailer.moveToIndex(index)) {
				log.error("No excerpt at " + start);
				return -1l;
			}

			if (!tailer.readDocument(wireIn -> id.set(record.id(wireIn)))) {
				log.warn("No record at " + index + " (" + cycle.get() + "," + seqNum + ")");
				return -1l;
			}
		}

		log.debug("Returning index " + index + (id.get() == t ? " *SPOT ON*" : ""));

		return index;
	}

	/**
	 * Translates a virtual record (sequence) number across all cycles into Chronicle queue index.
	 *
	 * @param recordNum   Record number between 0 and s
	 * @param metaData    Meta data
	 * @return            Chronicle queue index
	 * @throws            IndexOutOfBoundsException
	 */
	public static long translateRecordNum(final long recordNum, final ChronicleMetaData metaData) throws IndexOutOfBoundsException {

		final RollCycle rollCycle = metaData.rollCycle();
		final List<Tuple<Integer, Long>~Bugfix()~ cycleRanges = metaData.cycleRanges();

		if (cycleRanges == null || cycleRanges.isEmpty())
			throw new IllegalArgumentException("cycleRanges cannot be " + (cycleRanges != null ? "empty" : "null") + "!");

		if (recordNum >= metaData.size())
			throw new IndexOutOfBoundsException("recordNum out of bounds: " + recordNum + " >= " + metaData.size());

		long index = 0;

		for (Tuple<Integer, Long> cycleRange : cycleRanges) {
			// Accumulate until we locate cycle
			index += cycleRange.getSecond();

			if (index <= recordNum)
				continue;

			// Adjust to correct sequence number in the cycle
			index = cycleRange.getSecond() - (index - recordNum);
			//log.debug("Translated index: " + recordNum + " -> " + index + " (" + cycleRange.getSecond() + " - (" + index + " - " + recordNum + "))");

			return rollCycle.toIndex(cycleRange.getFirst(), index);
		}

		// Should never reach here!
		throw new RuntimeException("*** SHOULD NEVER SEE THIS ***");
	}

	/**
	 * Helper method.
	 * Binary Chronicle Excerpt record search.
	 * O(log N)
	 *
	 * @param tailer      Chronicle Excerpt tailer
	 * @param t           Search value (e.g. a timestamp or other sequential record id field)
	 * @param i           Relative index
	 * @param l           Length to go next (forwards or backwards)
	 * @param metaData    Meta data
	 * @param record      Function that extracts record id field
	 * @return            Chronicle queue index, or -1 if an error occurred
	 */
	static long binaryExcerptSearch(final ExcerptTailer tailer, final long t, final long i, final long l, final ChronicleMetaData metaData, ChronicleRecord record) {

		long current = translateRecordNum(i, metaData);

		log.debug("l: " + l + ", i: " + i + ", t: " + t + ", current: " + current);

		if (!tailer.moveToIndex(current)) {
			log.error("No excerpt at " + current);
			return -1l;
		}

		// Close enough, try to scan for exact match
		if (l <= 3l) {
			log.debug("Close enough: " + l);
			return sequentialExcerptSearch(tailer, t, current, metaData, record);
		}

		final AtomicLong id = new AtomicLong(0);
		tailer.readDocument(wireIn -> id.set(record.id(wireIn)));

		// Spot on! Not likely though
		if (id.get() == t) {
			log.debug("Spot on!");
			return current;
		}

		if (log.isDebugEnabled() && t > id.get()) log.debug("Going UP  : " + t + " > " + id);
		else if (log.isDebugEnabled() && t < id.get()) log.debug("Going DOWN: " + t + " < " + id);

		return binaryExcerptSearch(tailer, t, (t > id.get() ? i + l : i - l), l / 2l, metaData, record);
	}

	/**
	 * Helper method.
	 * Retrieves all cycles in a RollingChronicleQueue.
	 *
	 * @param queue Chronicle queue
	 * @throws      ParseException
	 * @return      List of cycles
	 */
	static List<Integer> getQueueCycles(final RollingChronicleQueue queue) throws ParseException {
		final List<Integer> cycles = new ArrayList<>();

		int cycle = queue.firstCycle();
		final int lastCycle = queue.lastCycle();

		cycles.add(cycle);	// Add first cycle

		while (cycle != lastCycle) {
			cycle = queue.nextCycle(cycle, TailerDirection.FORWARD);
			cycles.add(cycle);
		}

		return cycles;
	}
}>>

Tuple(package,name) ::= <<package ~package~;

/**
 * NextGen core utils 17.01.17
 */
public class ~name~<F, S> {

	private F first;
	private S second;

	public Tuple(F first, S second) {
		this.first = first;
		this.second = second;
	}

	public F getFirst() {
		return first;
	}

	public S getSecond() {
		return second;
	}

	public void setFirst(F first) {
		this.first = first;
	}

	public void setSecond(S second) {
		this.second = second;
	}

	@Override
	public String toString() {
		return "[" + first + "," + second + "]";
	}
}>>