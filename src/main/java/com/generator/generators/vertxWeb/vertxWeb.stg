/* uuid : 96f6cb83-eabb-4ee3-bd23-77923ced3591 */
delimiters "~", "~"

/** address,STRINGPROPERTY;handlerStatements,LISTPROPERTY;reference,STRINGPROPERTY;uri,STRINGPROPERTY; **/
eventBusClient(address,handlerStatements,reference,uri) ::= <<var ~reference~ = new EventBus("~uri~");

~reference~.onopen = function () {

    ~reference~.registerHandler("~address~", function (err, msg) {
        ~handlerStatements:{it|~it~;};separator="\n"~
    }) 
>>

/** handle,STRINGPROPERTY; **/
routeHandler(handle) ::= <<routingContext -> {
	~handle~;
}
>>

/** bodyHandler,STRINGPROPERTY;imports,LISTPROPERTY;name,STRINGPROPERTY;package,STRINGPROPERTY;port,STRINGPROPERTY;routes,KEYVALUELISTPROPERTY,action,handler,route;sockjs,STRINGPROPERTY;staticRoot,STRINGPROPERTY;verticles,KEYVALUELISTPROPERTY,deploy; **/
serverVerticle(bodyHandler,imports,name,package,port,routes,sockjs,staticRoot,verticles) ::= <<~if(package)~package ~package~;

~endif~
import io.vertx.core.*;
import io.vertx.ext.web.Router;
~imports:{it | import ~it~;}; separator="\n"~

public class ~name~ extends AbstractVerticle {

    private final static org.apache.log4j.Logger log = org.apache.log4j.Logger.getLogger(~name~.class);

    @Override
    public void start(Future<Void> startFuture) throws Exception {

        Router router = Router.router(vertx);
        ~if(sockjs)~~sockjs~~endif~

~if(bodyHandler)~		router.route().handler(io.vertx.ext.web.handler.BodyHandler.create());
~endif~

        ~routes:{it|router.~it.action~("~it.route~").handler(~it.handler~);};separator="\n"~
        ~if(staticRoot)~router.get("/*").handler(io.vertx.ext.web.handler.StaticHandler.create(~staticRoot~));~endif~

        ~verticles:{it|~it.deploy~};separator="\n"~
        vertx.createHttpServer().requestHandler(router::accept). listen(config().getInteger("~port~"));
		  startFuture.complete();
    }
}
>>

/** inbound,LISTPROPERTY;outbound,LISTPROPERTY;route,STRINGPROPERTY; **/
socksJSBridge(inbound,outbound,route) ::= <<final BridgeOptions bridgeOptions = new BridgeOptions()
    ~outbound:{it|.addOutboundPermitted(new PermittedOptions().setAddress("~it~"))};separator="\n"~
    ~inbound:{it|.addInboundPermitted(new PermittedOptions().setAddress("~it~"))};separator="\n"~;

router.route("~route~").handler(SockJSHandler.create(vertx).bridge(bridgeOptions, event -> {

  // You can also optionally provide a handler like this which will be passed any events that occur on the bridge
  // You can use this for monitoring or logging, or to change the raw messages in-flight.
  // It can also be used for fine grained access control.

  if (event.type() == BridgeEvent.Type.SOCKET_CREATED) {
    System.out.println("A socket was created");
  }

  // This signals that it's ok to process the event
  event.complete(true);
}));
>>

/** route,STRINGPROPERTY; **/
socksJSHandler(route) ::= <<// options
io.vertx.ext.web.handler.sockjs.SockJSHandlerOptions options = new io.vertx.ext.web.handler.sockjs.SockJSHandlerOptions().
    setHeartbeatInterval(2000);

BridgeOptions bridgeOptions = new BridgeOptions();
sockJSHandler.bridge(bridgeOptions);

io.vertx.ext.web.handler.sockjs.SockJSHandler sockJSHandler = io.vertx.ext.web.handler.sockjs.SockJSHandler.
    create(vertx, bridgeOptions);

router.route("~route~").handler(sockJSHandler);
>>

/** imports,LISTPROPERTY;name,STRINGPROPERTY;package,STRINGPROPERTY;port,STRINGPROPERTY;staticRoot,STRINGPROPERTY; **/
staticWebVerticle(imports,name,package,port,staticRoot) ::= <<~if(package)~package ~package~;

~endif~
import io.vertx.core.*;
import io.vertx.ext.web.Router;
~imports:{it | import ~it~;}; separator="\n"~

public class ~name~ extends AbstractVerticle {

    private final static org.apache.log4j.Logger log = org.apache.log4j.Logger.getLogger(~name~.class);

    @Override
    public void start(Future<Void> startFuture) throws Exception {

       Router router = Router.router(vertx);
		 router.route().handler(io.vertx.ext.web.handler.BodyHandler.create());
       router.get("/*").handler(io.vertx.ext.web.handler.StaticHandler.create(~staticRoot~));
	 	 vertx.createHttpServer().requestHandler(router::accept). listen(config().getInteger("~port~"));
		 startFuture.complete();
    }
}
>>
