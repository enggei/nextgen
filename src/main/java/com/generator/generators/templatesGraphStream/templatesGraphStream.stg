/* uuid : 7616a606-b105-4cf0-b044-4c0f42242c3b */
delimiters "~", "~"

/** comments,LISTPROPERTY;name,STRINGPROPERTY;packageName,STRINGPROPERTY;statements,KEYVALUELISTPROPERTY,declaration,name,newInstance; **/
GroupClassDeclaration(comments,name,packageName,statements) ::= <<~if(packageName)~package ~packageName~;

import org.graphstream.graph.Edge;
import org.graphstream.graph.Graph;
import org.graphstream.graph.Node;

import java.util.UUID;
import java.util.function.Consumer;

import static ~packageName~.~name~GraphStream.Attributes.*;
import static ~packageName~.~name~GraphStream.~name~GraphStreamLabels.*;

~endif~
/**
 * Wraps GraphStream methods based on '~name~.stg' file <br/>
 * ~comments:{it|~it~};separator="\n *"~
 */
public final class ~name~GraphStream {

	private final Graph graph;

	public enum ~name~GraphStreamLabels {
		~name~GraphStreamLabels,   	
		~statements:{it|~name~_~it.name~};separator=",\n"~,
		StringNode
	}

	public enum Attributes {
		Label, Value
	}

   public ~name~GraphStream(final Graph graph) {
 		this.graph = graph;

		graph.addAttribute("ui.stylesheet", "" +
			"graph { fill-color: rgb(245,245,245); } " +
			"edge { fill-color: grey; }" +
			"node:clicked { fill-color: rgb(223, 194, 125); stroke-color: rgb(191, 129, 45); } " +
			"node:selected { fill-color: rgb(223, 194, 125); stroke-color: rgb(191, 129, 45); } " +
			"node.StringNode { text-background-mode: plain; text-background-color: rgb(245,245,245); stroke-color: rgb(53, 151, 143); } " +
			~statements:{it|"node.~name~_~it.name~ { size: 20px, 25px; shape: box; text-background-mode: plain; text-background-color: rgb(245,245,245); fill-color: rgb(199, 234, 229); stroke-mode: plain; stroke-color: rgb(53, 151, 143); ~bugfix2()~"};separator=" + \n"~);
	}

   ~statements:{it|~it.newInstance~};separator="\r\n\r\n"~

	~statements:{it|~it.declaration~};separator="\r\n\r\n"~

	~defaultNodeTypes()~

	private static void debugNode(Node node) {
		for (String attribute : node.getAttributeKeySet()) {
			System.out.println(attribute + " : " + node.getAttribute(attribute));
		}
	}
} 
>>

/**  **/
bugfix2() ::= << } 
>>

/** groupName,STRINGPROPERTY;name,STRINGPROPERTY;properties,KEYVALUELISTPROPERTY,name,relationships,setter; **/
declaration(groupName,name,properties) ::= <<public static final class ~name~Node {

	private final Graph graph;
	private final UUID uuid;
	private final Node node;
~if(properties)~	
	~properties:{it|private Node ~it.name~Node;};separator="\n"~

	private enum Parameters {
		~properties:{it|~it.name~_param};separator=", "~
	}

	~properties:{it|~if(it.relationships)~
~it.relationships~~endif~}~

	private enum KeyValueLabels  {
		~properties:{it|~if(it.relationships)~~it.name;format="capitalize"~, ~endif~}~
	}
~endif~

	private ~name~Node(final Graph graph) {
		this.graph = graph;
		this.uuid = UUID.randomUUID();
		this.node = graph.addNode(this.uuid.toString());
		node.addAttribute("ui.class", ~groupName~_~name~.name());
		node.addAttribute("ui.label", "~name~");
		node.setAttribute("uuid", this.uuid);
		node.setAttribute(Label.name(), ~groupName~_~name~);
	}

	private ~name~Node(final Graph graph, final Node node) {
		debugNode(node);
		this.graph = graph;
		this.node = node;
		this.uuid = UUID.fromString(node.getAttribute("uuid"));
	}
/*
	public void delete() throws IllegalStateException {
		if (node.hasRelationship(Direction.INCOMING))
			throw new IllegalStateException(toString() + " has " + node.getDegree(Direction.INCOMING) + " dependent incoming relations. Delete these first.");
		tryToDeleteNode(node);
	}	
*/
	public Node node() {
		return node;
	}

	public UUID getUuid() {
		return uuid;
	}

	@Override
	public boolean equals(Object o) {
		if (this == o) return true;
		if (o == null || getClass() != o.getClass()) return false;
		~name~Node that = (~name~Node) o;
		return uuid.equals(that.uuid);
	}

	@Override
	public int hashCode() {
		return uuid.hashCode();
	}

	@Override
	public String toString() {
		return getClass().getName() + "  " + uuid;
	}

   ~properties:{it|~it.setter~};separator="\n\n"~
} 
>>

/**  **/
defaultNodeTypes() ::= <<public interface StringNode {

	public StringNode setValue(String value);

	public String getValue();

	public Node node();

	public UUID getUuid();
}

public static boolean isStringNode(Node node) {
	return node != null && StringNode.name().equals(node.getAttribute(Label.name()));
}

// convenience-method for instantiating a new StringNode, and setting the value
public Node newStringNode(String value) {
	if (value==null) throw new IllegalArgumentException("value for newStringNode cannot be null");
	
	final UUID uuid = UUID.randomUUID();
	final Node node = graph.addNode(uuid.toString());
	node.setAttribute("uuid", uuid.toString());
	node.setAttribute(Label.name(), StringNode);
	node.addAttribute("ui.class", StringNode.name());
	node.addAttribute("ui.label", value);

	return newStringNode(node).setValue(value).node();
}

public static StringNode newStringNode(Node node) {
	if (node==null) throw new IllegalArgumentException("node for newStringNode cannot be null");
	
	final UUID uuid = UUID.fromString(node.getAttribute("uuid"));

	return new StringNode() {
		@Override
		public StringNode setValue(String value) {
			node.setAttribute(Value.name(), value);
			return this;
		}

		@Override
		public String getValue() {
			return node.getAttribute(Value.name());
		}

		@Override
		public Node node() {
			return node;
		}

		@Override
		public UUID getUuid() {
			return uuid;
		}

		@Override
		public boolean equals(Object o) {
			if (this == o) return true;
			if (o == null || getClass() != o.getClass()) return false;
			StringNode that = (StringNode) o;
			return uuid.equals(that.getUuid());
		}

		@Override
		public int hashCode() {
			return uuid.hashCode();
		}

		@Override
		public String toString() {
			return getValue();
		}	
	};
} 
>>

/** kvNames,LISTPROPERTY;propertyName,STRINGPROPERTY;statementName,STRINGPROPERTY; **/
keyValueListSetter(kvNames,propertyName,statementName) ::= <<public interface ~propertyName;format="capitalize"~KeyValue {

	~kvNames:{it|public Node get~it;format="capitalize"~Value();};separator="\n\n"~

	~kvNames:{it|public ~propertyName;format="capitalize"~KeyValue set~it;format="capitalize"~Value(Node value);};separator="\n\n"~

	public Node node();

	public UUID getUuid();
}

public ~statementName~Node add~propertyName;format="capitalize"~Value(~propertyName;format="capitalize"~KeyValue target) {
	if (node == null) return this;
	graph.addEdge("~propertyName~_" + UUID.randomUUID().toString(), this.node, target.node());
   return this;
}

public ~propertyName;format="capitalize"~KeyValue new~propertyName;format="capitalize"~KeyValue() {
	final UUID uuid = UUID.randomUUID();
	final Node node = graph.addNode(uuid.toString());
	node.setAttribute("uuid", uuid.toString());
	node.setAttribute(Label.name(), "~propertyName;format="capitalize"~KeyValue");
	return new~propertyName;format="capitalize"~KeyValue(node);
}

public ~propertyName;format="capitalize"~KeyValue new~propertyName;format="capitalize"~KeyValue(Node node) {
	if (node==null) throw new IllegalArgumentException("node for new~propertyName;format="capitalize"~KeyValue cannot be null");
	
	final UUID uuid = UUID.fromString(node.getAttribute("uuid"));

	return new ~propertyName;format="capitalize"~KeyValue() {
		
		~kvNames:{it|@Override
public Node get~it;format="capitalize"~Value() {
	for (Edge edge : node)
  		if (edge.getId().startsWith("~it~_" + uuid)) 
  			return edge.getOpposite(node);
	return null;
~bugfix2()~

@Override
public ~propertyName;format="capitalize"~KeyValue set~it;format="capitalize"~Value(Node target) {
	for (Edge edge : node) 
		if (edge.getId().startsWith("~it~_" + uuid)) { 
			graph.removeEdge(edge);
			break;
		~bugfix2()~

	if (target==null) return this;

	graph.addEdge("~it~_" + UUID.randomUUID(), node, target);
	return this;
~bugfix2()~
 		};separator="\n"~
		@Override
		public Node node() {
			return node;
		}

		@Override
		public UUID getUuid() {
			return uuid;
		}

		@Override
		public boolean equals(Object o) {
			if (this == o) return true;
			if (o == null || getClass() != o.getClass()) return false;
			StringNode that = (StringNode) o;
			return uuid.equals(that.getUuid());
		}

		@Override
		public int hashCode() {
			return uuid.hashCode();
		}
	};
}

public void forEach~propertyName;format="capitalize"~Value(Consumer<~propertyName;format="capitalize"~KeyValue> consumer) {
	for (Edge edge : node) {
		if (edge.getId().startsWith("~propertyName;format="capitalize"~KeyValue_")) {
			consumer.accept(new~propertyName;format="capitalize"~KeyValue(edge.getOpposite(this.node)));
		}
	}
} 
>>

/** name,STRINGPROPERTY;types,LISTPROPERTY; **/
keyValueRelationships(name,types) ::= <<private enum ~name;format="capitalize"~Relationships {
	~types:{it|~it~};separator=", "~
} 
>>

/** propertyName,STRINGPROPERTY;statementName,STRINGPROPERTY; **/
listSetter(propertyName,statementName) ::= <<// ~propertyName~
public ~statementName~Node add~propertyName;format="capitalize"~Value(Node target) {
	if (node == null) return this;
	graph.addEdge("~propertyName~_" + UUID.randomUUID().toString(), this.node, target);
   return this;
}

public void forEach~propertyName;format="capitalize"~(Consumer<Node> consumer) {
	for (Edge edge : this.node) {
		if (edge.getId().startsWith("~propertyName~_")) {
			consumer.accept(edge.getOpposite(this.node));
		}
	}
} 
>>

/** groupName,STRINGPROPERTY;name,STRINGPROPERTY; **/
newInstance(groupName,name) ::= <<public static boolean is~name;format="capitalize"~(Node node) {
	return node != null && node.hasLabel(~groupName~_~name~.name());
}

public ~name~Node new~name;format="capitalize"~() {
	return new ~name~Node(graph);
}

public ~name~Node new~name;format="capitalize"~(Node node) {
	return new ~name~Node(graph, node);
}

/*
todo:
public void forEach~name;format="capitalize"~Nodes(Consumer<~name~Node> consumer) {
	graph.findNodes(~groupName~_~name~).
		forEachRemaining(new Consumer<Node>() {
			@Override
			public void accept(Node node) {
				consumer.accept(new ~name~Node(graph, node));
			}
		});
}

public void visit~name;format="capitalize"~Nodes(Consumer<Node> consumer) {
	graph.findNodes(~groupName~_~name~).
		forEachRemaining(consumer);
}
*/ 
>>

/** propertyName,STRINGPROPERTY;statementName,STRINGPROPERTY; **/
stringSetter(propertyName,statementName) ::= <<// ~propertyName~
public ~statementName~Node set~propertyName;format="capitalize"~(Node target) {
	for (Edge edge : this.node) {
		if (edge.getId().equals("~propertyName~_" + uuid)) {
			graph.removeEdge(edge);
			break;
		}
	}

	if (target==null) return this;

	graph.addEdge("~propertyName~_" + UUID.randomUUID(), this.node, target);
	this.~propertyName~Node = node;
	return this;
}

public Node get~propertyName;format="capitalize"~() {
	if (this.~propertyName~Node != null) return this.~propertyName~Node;
	
	for (Edge edge : this.node) {
		if (edge.getId().startsWith("~propertyName~_" + uuid)) {
			this.~propertyName~Node = edge.getOpposite(this.node);
			return this.~propertyName~Node;
		}
	}

	return null;
}

public void remove~propertyName;format="capitalize"~() {
	for (Edge edge : this.node) {
		if (edge.getId().equals("~propertyName~_" + uuid)) {
			graph.removeEdge(edge);
			this.~propertyName~Node = null;
  			break;
		}
	}
} 
>>
